{"version":3,"sources":["webpack:///./public/app/core/components/TraceToLogsSettings.tsx","webpack:///./public/app/plugins/datasource/zipkin/utils/transforms.ts","webpack:///./public/app/plugins/datasource/zipkin/datasource.ts","webpack:///./public/app/plugins/datasource/zipkin/constants.ts","webpack:///./node_modules/react-use/esm/useMount.js","webpack:///./public/app/plugins/datasource/zipkin/QueryField.tsx","webpack:///./public/app/plugins/datasource/zipkin/module.ts","webpack:///./public/app/plugins/datasource/zipkin/ConfigEditor.tsx","webpack:///./node_modules/react-use/esm/useEffectOnce.js"],"names":["TraceToLogsSettings","options","onOptionsChange","styles","useStyles","getStyles","className","infoText","tooltip","pluginId","current","jsonData","tracesToLogs","datasourceUid","noDefault","onChange","ds","updateDatasourcePluginJsonDataOption","uid","tags","theme","css","spacing","md","colors","textSemiWeak","transformSpan","span","jaegerSpan","duration","flags","logs","annotations","map","transformAnnotation","operationName","name","processID","localEndpoint","serviceName","remoteEndpoint","startTime","timestamp","spanID","id","traceID","traceId","warnings","Object","keys","key","type","value","references","parentId","refType","kind","annotation","fields","gatherProcesses","zSpans","processes","reduce","acc","push","endpointToProcess","keyBy","endpoint","valueToTag","ipv4","ipv6","port","filter","identity","ZipkinDatasource","instanceSettings","targets","query","this","request","encodeURIComponent","pipe","responseToDataQueryResponse","of","emptyDataQueryResponse","url","params","hideFromInspector","toPromise","res","data","metadataRequest","status","message","apiUrl","serializeParams","req","length","getBackendSrv","fetch","DataSourceApi","response","MutableDataFrame","FieldType","trace","values","spans","meta","preferredVisualisationType","fn","useEffectOnce","noTracesFoundOptions","label","isLeaf","noTracesOptions","plugin","DataSourcePlugin","setConfigEditor","defaultUrl","dataSourceConfig","showAccessOptions","setExploreQueryField","onRunQuery","datasource","serviceOptions","useAsyncFn","services","sort","service","appEvents","emit","AppEvents","alertError","servicesOptions","useMount","useServices","isMounted","useMountedState","useState","allOptions","setAllOptions","fetchSpans","state","spanOptions","fromPairs","undefined","fetchTraces","spanName","search","traces","newTraces","rootSpan","find","Math","floor","onLoadOptions","useCallback","selectedOptions","useLoadOptions","onSelectTrace","cascaderOptions","useMemo","children","traceName","useMapToCascaderOptions","loadData","aria-label","selectors","components","QueryField","container","style","width","e","currentTarget","effect"],"mappings":"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","file":"zipkinPlugin.1c3a1c85d09a392be724.js","sourcesContent":["import {\n  DataSourceJsonData,\n  DataSourcePluginOptionsEditorProps,\n  GrafanaTheme,\n  updateDatasourcePluginJsonDataOption,\n} from '@grafana/data';\nimport { InlineFormLabel, TagsInput, useStyles } from '@grafana/ui';\nimport { css } from 'emotion';\nimport React from 'react';\nimport { DataSourcePicker } from './Select/DataSourcePicker';\n\nexport interface TraceToLogsOptions {\n  datasourceUid?: string;\n  tags?: string[];\n}\n\nexport interface TraceToLogsData extends DataSourceJsonData {\n  tracesToLogs?: TraceToLogsOptions;\n}\n\ninterface Props extends DataSourcePluginOptionsEditorProps<TraceToLogsData> {}\n\nexport function TraceToLogsSettings({ options, onOptionsChange }: Props) {\n  const styles = useStyles(getStyles);\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Trace to logs</h3>\n\n      <div className={styles.infoText}>\n        Trace to logs let&apos;s you navigate from a trace span to the selected data source&apos;s log.\n      </div>\n\n      <div className=\"gf-form\">\n        <InlineFormLabel tooltip=\"The data source the trace is going to navigate to\">Data source</InlineFormLabel>\n        <DataSourcePicker\n          pluginId=\"loki\"\n          current={options.jsonData.tracesToLogs?.datasourceUid}\n          noDefault={true}\n          onChange={(ds) =>\n            updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n              datasourceUid: ds.uid,\n              tags: options.jsonData.tracesToLogs?.tags,\n            })\n          }\n        />\n      </div>\n\n      <div className=\"gf-form\">\n        <InlineFormLabel tooltip=\"Tags that will be used in the Loki query. Default tags: 'cluster', 'hostname', 'namespace', 'pod'\">\n          Tags\n        </InlineFormLabel>\n        <TagsInput\n          tags={options.jsonData.tracesToLogs?.tags}\n          onChange={(tags) =>\n            updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n              datasourceUid: options.jsonData.tracesToLogs?.datasourceUid,\n              tags: tags,\n            })\n          }\n        />\n      </div>\n    </>\n  );\n}\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing.md};\n    color: ${theme.colors.textSemiWeak};\n  `,\n});\n","import { identity, keyBy } from 'lodash';\nimport { ZipkinAnnotation, ZipkinEndpoint, ZipkinSpan } from '../types';\nimport * as Jaeger from '../../jaeger/types';\n\n/**\n * Transforms response to format similar to Jaegers as we use Jaeger ui on the frontend.\n */\nexport function transformResponse(zSpans: ZipkinSpan[]): Jaeger.TraceResponse {\n  return {\n    processes: gatherProcesses(zSpans),\n    traceID: zSpans[0].traceId,\n    spans: zSpans.map(transformSpan),\n    warnings: null,\n  };\n}\n\nfunction transformSpan(span: ZipkinSpan): Jaeger.Span {\n  const jaegerSpan: Jaeger.Span = {\n    duration: span.duration,\n    // TODO: not sure what this is\n    flags: 1,\n    logs: span.annotations?.map(transformAnnotation) ?? [],\n    operationName: span.name,\n    processID: span.localEndpoint?.serviceName || span.remoteEndpoint?.serviceName || 'unknown',\n    startTime: span.timestamp,\n    spanID: span.id,\n    traceID: span.traceId,\n    warnings: null as any,\n    tags: Object.keys(span.tags || {}).map((key) => {\n      // If tag is error we remap it to simple boolean so that the Jaeger ui will show an error icon.\n      return {\n        key,\n        type: key === 'error' ? 'bool' : 'string',\n        value: key === 'error' ? true : span.tags![key],\n      };\n    }),\n    references: span.parentId\n      ? [\n          {\n            refType: 'CHILD_OF',\n            spanID: span.parentId,\n            traceID: span.traceId,\n          },\n        ]\n      : [],\n  };\n  if (span.kind) {\n    jaegerSpan.tags = [\n      {\n        key: 'kind',\n        type: 'string',\n        value: span.kind,\n      },\n      ...(jaegerSpan.tags ?? []),\n    ];\n  }\n\n  return jaegerSpan;\n}\n\n/**\n * Maps annotations as a Jaeger log as that seems to be the closest thing.\n * See https://zipkin.io/zipkin-api/#/default/get_trace__traceId_\n */\nfunction transformAnnotation(annotation: ZipkinAnnotation): Jaeger.TraceLog {\n  return {\n    timestamp: annotation.timestamp,\n    fields: [\n      {\n        key: 'annotation',\n        type: 'string',\n        value: annotation.value,\n      },\n    ],\n  };\n}\n\nfunction gatherProcesses(zSpans: ZipkinSpan[]): Record<string, Jaeger.TraceProcess> {\n  const processes = zSpans.reduce((acc, span) => {\n    if (span.localEndpoint) {\n      acc.push(endpointToProcess(span.localEndpoint));\n    }\n    if (span.remoteEndpoint) {\n      acc.push(endpointToProcess(span.remoteEndpoint));\n    }\n    return acc;\n  }, [] as Jaeger.TraceProcess[]);\n  return keyBy(processes, 'serviceName');\n}\n\nfunction endpointToProcess(endpoint: ZipkinEndpoint): Jaeger.TraceProcess {\n  return {\n    serviceName: endpoint.serviceName,\n    tags: [\n      valueToTag('ipv4', endpoint.ipv4, 'string'),\n      valueToTag('ipv6', endpoint.ipv6, 'string'),\n      valueToTag('port', endpoint.port, 'number'),\n    ].filter(identity) as Jaeger.TraceKeyValuePair[],\n  };\n}\n\nfunction valueToTag(\n  key: string,\n  value: string | number | undefined,\n  type: string\n): Jaeger.TraceKeyValuePair | undefined {\n  if (!value) {\n    return undefined;\n  }\n  return {\n    key,\n    type,\n    value,\n  };\n}\n","import {\n  DataQuery,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  FieldType,\n  MutableDataFrame,\n} from '@grafana/data';\nimport { BackendSrvRequest, FetchResponse, getBackendSrv } from '@grafana/runtime';\nimport { Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { apiPrefix } from './constants';\nimport { ZipkinSpan } from './types';\nimport { transformResponse } from './utils/transforms';\n\nexport interface ZipkinQuery extends DataQuery {\n  query: string;\n}\n\nexport class ZipkinDatasource extends DataSourceApi<ZipkinQuery> {\n  constructor(private instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n  }\n\n  query(options: DataQueryRequest<ZipkinQuery>): Observable<DataQueryResponse> {\n    const traceId = options.targets[0]?.query;\n    if (traceId) {\n      return this.request<ZipkinSpan[]>(`${apiPrefix}/trace/${encodeURIComponent(traceId)}`).pipe(\n        map(responseToDataQueryResponse)\n      );\n    } else {\n      return of(emptyDataQueryResponse);\n    }\n  }\n\n  async metadataRequest(url: string, params?: Record<string, any>): Promise<any> {\n    const res = await this.request(url, params, { hideFromInspector: true }).toPromise();\n    return res.data;\n  }\n\n  async testDatasource(): Promise<{ status: string; message: string }> {\n    await this.metadataRequest(`${apiPrefix}/services`);\n    return { status: 'success', message: 'Data source is working' };\n  }\n\n  getQueryDisplayText(query: ZipkinQuery): string {\n    return query.query;\n  }\n\n  private request<T = any>(\n    apiUrl: string,\n    data?: any,\n    options?: Partial<BackendSrvRequest>\n  ): Observable<FetchResponse<T>> {\n    const params = data ? serializeParams(data) : '';\n    const url = `${this.instanceSettings.url}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return getBackendSrv().fetch<T>(req);\n  }\n}\n\nfunction responseToDataQueryResponse(response: { data: ZipkinSpan[] }): DataQueryResponse {\n  return {\n    data: [\n      new MutableDataFrame({\n        fields: [\n          {\n            name: 'trace',\n            type: FieldType.trace,\n            // There is probably better mapping than just putting everything in as a single value but that's how\n            // we do it with jaeger and is the simplest right now.\n            values: response?.data ? [transformResponse(response?.data)] : [],\n          },\n        ],\n        meta: {\n          preferredVisualisationType: 'trace',\n        },\n      }),\n    ],\n  };\n}\n\nconst emptyDataQueryResponse = {\n  data: [\n    new MutableDataFrame({\n      fields: [\n        {\n          name: 'trace',\n          type: FieldType.trace,\n          values: [],\n        },\n      ],\n      meta: {\n        preferredVisualisationType: 'trace',\n      },\n    }),\n  ],\n};\n","export const apiPrefix = '/api/v2';\n","import useEffectOnce from './useEffectOnce';\nvar useMount = function (fn) {\n    useEffectOnce(function () {\n        fn();\n    });\n};\nexport default useMount;\n","import { AppEvents, ExploreQueryFieldProps } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { ButtonCascader, CascaderOption } from '@grafana/ui';\nimport { fromPairs } from 'lodash';\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { useAsyncFn, useMount, useMountedState } from 'react-use';\nimport { AsyncState } from 'react-use/lib/useAsyncFn';\nimport { appEvents } from '../../../core/core';\nimport { apiPrefix } from './constants';\nimport { ZipkinDatasource, ZipkinQuery } from './datasource';\nimport { ZipkinSpan } from './types';\n\ntype Props = ExploreQueryFieldProps<ZipkinDatasource, ZipkinQuery>;\n\nexport const QueryField = ({ query, onChange, onRunQuery, datasource }: Props) => {\n  const serviceOptions = useServices(datasource);\n  const { onLoadOptions, allOptions } = useLoadOptions(datasource);\n\n  const onSelectTrace = useCallback(\n    (values: string[], selectedOptions: CascaderOption[]) => {\n      if (selectedOptions.length === 3) {\n        const traceID = selectedOptions[2].value;\n        onChange({ ...query, query: traceID });\n        onRunQuery();\n      }\n    },\n    [onChange, onRunQuery, query]\n  );\n\n  let cascaderOptions = useMapToCascaderOptions(serviceOptions, allOptions);\n\n  return (\n    <>\n      <div className=\"gf-form-inline gf-form-inline--nowrap\">\n        <div className=\"gf-form flex-shrink-0\">\n          <ButtonCascader options={cascaderOptions} onChange={onSelectTrace} loadData={onLoadOptions}>\n            Traces\n          </ButtonCascader>\n        </div>\n        <div className=\"gf-form gf-form--grow flex-shrink-1\">\n          <div className=\"slate-query-field__wrapper\">\n            <div className=\"slate-query-field\" aria-label={selectors.components.QueryField.container}>\n              <input\n                style={{ width: '100%' }}\n                value={query.query || ''}\n                onChange={(e) =>\n                  onChange({\n                    ...query,\n                    query: e.currentTarget.value,\n                  })\n                }\n              />\n            </div>\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\n// Exported for tests\nexport function useServices(datasource: ZipkinDatasource): AsyncState<CascaderOption[]> {\n  const url = `${apiPrefix}/services`;\n\n  const [servicesOptions, fetch] = useAsyncFn(async (): Promise<CascaderOption[]> => {\n    try {\n      const services: string[] | null = await datasource.metadataRequest(url);\n      if (services) {\n        return services.sort().map((service) => ({\n          label: service,\n          value: service,\n          isLeaf: false,\n        }));\n      }\n      return [];\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load services from Zipkin', error]);\n      throw error;\n    }\n  }, [datasource]);\n\n  useMount(() => {\n    // We should probably call this periodically to get new services after mount.\n    fetch();\n  });\n\n  return servicesOptions;\n}\n\ntype OptionsState = {\n  [serviceName: string]: {\n    [spanName: string]: {\n      [traceId: string]: string;\n    };\n  };\n};\n\n// Exported for tests\nexport function useLoadOptions(datasource: ZipkinDatasource) {\n  const isMounted = useMountedState();\n  const [allOptions, setAllOptions] = useState({} as OptionsState);\n\n  const [, fetchSpans] = useAsyncFn(\n    async function findSpans(service: string): Promise<void> {\n      const url = `${apiPrefix}/spans`;\n      try {\n        // The response of this should have been full ZipkinSpan objects based on API docs but is just list\n        // of span names.\n        // TODO: check if this is some issue of version used or something else\n        const response: string[] = await datasource.metadataRequest(url, { serviceName: service });\n        if (isMounted()) {\n          setAllOptions((state) => {\n            const spanOptions = fromPairs(response.map((span: string) => [span, undefined]));\n            return {\n              ...state,\n              [service]: spanOptions as any,\n            };\n          });\n        }\n      } catch (error) {\n        appEvents.emit(AppEvents.alertError, ['Failed to load spans from Zipkin', error]);\n        throw error;\n      }\n    },\n    [datasource, allOptions]\n  );\n\n  const [, fetchTraces] = useAsyncFn(\n    async function findTraces(serviceName: string, spanName: string): Promise<void> {\n      const url = `${apiPrefix}/traces`;\n      const search = {\n        serviceName,\n        spanName,\n        // See other params and default here https://zipkin.io/zipkin-api/#/default/get_traces\n      };\n      try {\n        // This should return just root traces as there isn't any nesting\n        const traces: ZipkinSpan[][] = await datasource.metadataRequest(url, search);\n        if (isMounted()) {\n          const newTraces = traces.length\n            ? fromPairs(\n                traces.map((trace) => {\n                  const rootSpan = trace.find((span) => !span.parentId)!;\n\n                  return [`${rootSpan.name} [${Math.floor(rootSpan.duration / 1000)} ms]`, rootSpan.traceId];\n                })\n              )\n            : noTracesOptions;\n\n          setAllOptions((state) => {\n            const spans = state[serviceName];\n            return {\n              ...state,\n              [serviceName]: {\n                ...spans,\n                [spanName]: newTraces,\n              },\n            };\n          });\n        }\n      } catch (error) {\n        appEvents.emit(AppEvents.alertError, ['Failed to load spans from Zipkin', error]);\n        throw error;\n      }\n    },\n    [datasource]\n  );\n\n  const onLoadOptions = useCallback(\n    (selectedOptions: CascaderOption[]) => {\n      const service = selectedOptions[0].value;\n      if (selectedOptions.length === 1) {\n        fetchSpans(service);\n      } else if (selectedOptions.length === 2) {\n        const spanName = selectedOptions[1].value;\n        fetchTraces(service, spanName);\n      }\n    },\n    [fetchSpans, fetchTraces]\n  );\n\n  return {\n    onLoadOptions,\n    allOptions,\n  };\n}\n\nfunction useMapToCascaderOptions(services: AsyncState<CascaderOption[]>, allOptions: OptionsState) {\n  return useMemo(() => {\n    let cascaderOptions: CascaderOption[] = [];\n\n    if (services.value && services.value.length) {\n      cascaderOptions = services.value.map((services) => {\n        return {\n          ...services,\n          children:\n            allOptions[services.value] &&\n            Object.keys(allOptions[services.value]).map((spanName) => {\n              return {\n                label: spanName,\n                value: spanName,\n                isLeaf: false,\n                children:\n                  allOptions[services.value][spanName] &&\n                  Object.keys(allOptions[services.value][spanName]).map((traceName) => {\n                    return {\n                      label: traceName,\n                      value: allOptions[services.value][spanName][traceName],\n                    };\n                  }),\n              };\n            }),\n        };\n      });\n    } else if (services.value && !services.value.length) {\n      cascaderOptions = noTracesFoundOptions;\n    }\n\n    return cascaderOptions;\n  }, [services, allOptions]);\n}\n\nconst NO_TRACES_KEY = '__NO_TRACES__';\nconst noTracesFoundOptions = [\n  {\n    label: 'No traces found',\n    value: 'no_traces',\n    isLeaf: true,\n\n    // Cannot be disabled because then cascader shows 'loading' for some reason.\n    // disabled: true,\n  },\n];\n\nconst noTracesOptions = {\n  '[No traces in time range]': NO_TRACES_KEY,\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ZipkinDatasource } from './datasource';\nimport { QueryField } from './QueryField';\nimport { ConfigEditor } from './ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(ZipkinDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(QueryField);\n","import { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { TraceToLogsSettings } from 'app/core/components/TraceToLogsSettings';\nimport React from 'react';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor: React.FC<Props> = ({ options, onOptionsChange }) => {\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:9411\"\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <TraceToLogsSettings options={options} onOptionsChange={onOptionsChange} />\n    </>\n  );\n};\n","import { useEffect } from 'react';\nvar useEffectOnce = function (effect) {\n    useEffect(effect, []);\n};\nexport default useEffectOnce;\n"],"sourceRoot":""}