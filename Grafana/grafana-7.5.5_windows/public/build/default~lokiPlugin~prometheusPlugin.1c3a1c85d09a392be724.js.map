{"version":3,"sources":["webpack:///./public/app/plugins/datasource/prometheus/language_provider.ts","webpack:///./node_modules/lru-cache/node_modules/yallist/iterator.js","webpack:///./node_modules/lru-cache/node_modules/yallist/yallist.js","webpack:///./node_modules/lru-cache/index.js","webpack:///./public/app/plugins/datasource/prometheus/language_utils.ts","webpack:///./public/app/plugins/datasource/prometheus/add_label_to_query.ts","webpack:///./public/app/plugins/datasource/prometheus/promql.ts"],"names":["DEFAULT_KEYS","SUGGESTIONS_LIMIT","wrapLabel","label","setFunctionKind","suggestion","kind","PREFIX_DELIMITER_REGEX","PromQlLanguageProvider","datasource","initialValues","labelsCache","LRU","request","url","defaultValue","params","metadataRequest","res","data","console","error","start","lookupsDisabled","tRange","getTimeRange","toString","end","metrics","fixSummariesMetadata","metricsMetadata","processHistogramMetrics","values","processHistogramLabels","histogramMetrics","slice","sort","provideCompletionItems","prefix","text","value","labelKey","wrapperClasses","context","history","emptyResult","suggestions","empty","document","length","selectedLines","getTextsAtRange","selection","currentLine","size","first","getText","nextCharacter","anchor","offset","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","match","operatorsPattern","isNextOperand","includes","getRangeCompletionItems","getLabelCompletionItems","getAggregationCompletionItems","getEmptyCompletionItems","getBeginningCompletionItems","getTermCompletionItems","historyItems","_","chain","map","h","query","expr","filter","uniq","take","item","cutoffTs","Date","now","historyForItem","ts","count","recent","hint","lastQueried","dateTime","fromNow","documentation","addHistoryMetadata","push","prefixMatch","skipSort","items","FUNCTIONS","limitInfo","addLimitInfo","limitSuggestions","m","metric","metadata","type","help","toUpperCase","addMetricsMetadata","queryText","getBlocks","reduce","block","blockText","anchorBlock","key","queryOffset","openParensAggregationIndex","lastIndexOf","openParensSelectorIndex","closeParensSelectorIndex","indexOf","closeParensAggregationIndex","result","selectorString","replace","selector","parseSelector","getLabelValues","labelValues","Object","keys","line","cursorOffset","suffix","substr","isValueStart","isValueEnd","isPreValue","hasValuePrefix","parsedSelector","containsMetric","existingKeys","labelKeys","warn","possibleKeys","difference","newItems","newSuggestion","fetchLabelValues","fetchSeriesLabels","name","withName","urlParams","cacheParams","URLSearchParams","roundSecToMin","cacheKey","get","processLabels","set","fetchDefaultLabels","once","Promise","all","acc","timeRange","assign","s","split","pop","trimLeft","RATE_RANGES","this","undefined","PromqlSyntax","LanguageProvider","module","exports","Yallist","prototype","Symbol","iterator","walker","head","next","list","self","tail","forEach","arguments","i","l","insert","node","inserted","Node","prev","unshift","create","removeNode","Error","unshiftNode","pushNode","shift","fn","thisp","call","forEachReverse","n","getReverse","mapReverse","initial","TypeError","reduceReverse","toArray","arr","Array","toArrayReverse","from","to","ret","sliceReverse","splice","deleteCount","reverse","p","require","er","MAX","LENGTH","LENGTH_CALCULATOR","ALLOW_STALE","MAX_AGE","DISPOSE","NO_DISPOSE_ON_SET","LRU_LIST","CACHE","UPDATE_AGE_ON_GET","naiveLength","LRUCache","options","max","Infinity","lc","stale","maxAge","dispose","noDisposeOnSet","updateAgeOnGet","reset","forEachStep","k","hit","Map","isStale","v","e","len","has","del","trim","Entry","expiresAt","mL","allowStale","mA","lC","doUse","diff","labels","resultSet","Set","regexp","RegExp","index","test","add","__name__","valueSet","rest","valueArray","selectorRegexp","labelRegexp","prefixOpen","prefixClose","suffixCloseIndex","suffixClose","suffixOpenIndex","suffixOpen","operator","labelOffset","valueStart","valueEnd","metricPrefix","metricMatch","cleanSelector","join","expandRecordingRules","mapping","ruleNames","rulesRegex","queryArray","pre","post","invalidLabelsRegex","invalidLabelsRegexp","indexOfRegexMatch","exprBeforeRegexMatch","exprAfterRegexMatch","arrayOfLabelObjects","Boolean","obj","addLabelToQuery","addLabelsToExpression","summaryMetadata","roundMsToMin","milliseconds","seconds","Math","floor","keywords","builtInWords","metricsAndKeywordsRegexp","hasNoMetrics","previousWord","transformedValue","word","isMetric","insideSelector","position","openChar","closeChar","nextSelectorStart","nextSelectorEnd","previousWordIsKeyWord","isColonBounded","endsWith","startsWithQuote","isTemplateVariable","isTimeUnit","Number","isWordMetric","exec","parts","lastIndex","selectorWithLabel","addLabelToSelector","labelValue","labelOperator","parsedLabels","operatorForLabelKey","formatted","uniqWith","isEqual","compact","sortBy","sortText","insertText","detail","tokenizer","comment","pattern","lookbehind","inside","alias","punctuation","greedy","function","f","number"],"mappings":"8xEAqBA,IAAMA,EAAe,CAAC,MAAO,YAKhBC,EAAoB,IAE3BC,EAAY,SAACC,GAAD,MAAoC,CAAEA,UAElDC,EAAkB,SAACC,GAEvB,OADAA,EAAWC,KAAO,WACXD,GA8BT,IAAME,EAAyB,4FAEVC,E,YAenB,WAAYC,EAAkCC,GAAiD,M,IAAA,O,4FAAA,S,EAC7F,K,EAAA,oB,iDAHMC,YAAc,IAAIC,IAAsC,IAE+B,EAsB/FC,QAtB+F,4CAsBrF,WAAOC,EAAaC,GAApB,2GAAuCC,EAAvC,+BAAgD,GAAhD,kBAEY,EAAKP,WAAWQ,gBAAgBH,EAAKE,GAFjD,cAEAE,EAFA,yBAGCA,EAAIC,KAAKA,MAHV,gCAKNC,QAAQC,MAAR,MALM,iCAQDN,GARC,yDAtBqF,0DAiC/FO,MAjC+F,2BAiCvF,yGACF,EAAKb,WAAWc,gBADd,yCAEG,IAFH,cAKAC,EAAS,EAAKf,WAAWgB,eACzBT,EAAS,CACbM,MAAOE,EAAM,MAAUE,WACvBC,IAAKH,EAAM,IAAQE,YARf,yCAYe,EAAKb,QAZpB,gCAYiC,GAAIG,GAZrC,cAYN,EAAKY,QAZC,YAaiBC,IAbjB,UAa4C,EAAKhB,QAAQ,mBAAoB,IAb7E,2BAaN,EAAKiB,iBAbC,cAcN,EAAKC,wBAAwB,EAAKH,SAd5B,kBAgBC,IAhBD,4CAjCuF,EAoD/FG,wBAA0B,SAACZ,GAAmB,IACpCa,EAAWC,YAAuBd,GAAlCa,OAEJA,GAAUA,EAAM,WAClB,EAAKE,iBAAmBF,EAAM,SAAaG,QAAQC,SAxDwC,EA4D/FC,uBA5D+F,4CA4DtE,mJACrBC,EADqB,EACrBA,OAAQC,EADa,EACbA,KAAMC,EADO,EACPA,MAAOC,EADA,EACAA,SAAUC,EADV,EACUA,eACjCC,EAFuB,+BAE+B,CAAEC,QAAS,IAE3DC,EAA+B,CAAEC,YAAa,IAE/CN,EANkB,yCAOdK,GAPc,UAWjBE,EAAuC,IAA/BP,EAAMQ,SAAST,KAAKU,OAC5BC,EAAgBV,EAAMQ,SAASG,gBAAgBX,EAAMY,WACrDC,EAAqC,IAAvBH,EAAcI,KAAaJ,EAAcK,QAAQC,UAAY,KAE3EC,EAAgBJ,EAAcA,EAAYb,EAAMY,UAAUM,OAAOC,QAAU,KAG3EC,EAAkBlB,EAAeO,OAAS,EAE1CY,EAAqBvB,IAAWsB,EAGhCE,GAAYL,GAAmC,MAAlBA,EAG7BM,EAAazB,IAAWC,EAAKyB,MAAM,gBAAkBF,EAGrDG,EAAmB,YACnBC,EAAgB3B,EAAKyB,MAAMC,IAG7BvB,EAAeyB,SAAS,iBAjCL,0CAmCd,EAAKC,2BAnCS,YAoCZ1B,EAAeyB,SAAS,kBApCZ,0CAsCd,EAAKE,wBAAwB,CAAE/B,SAAQC,OAAMC,QAAOC,WAAUC,oBAtChD,YAuCZA,EAAeyB,SAAS,uBAvCZ,0CAyCd,EAAKG,8BAA8B9B,IAzCrB,YA0CZO,EA1CY,0CA4Cd,EAAKwB,wBAAwB5B,IA5Cf,YA6CZkB,IAAsBC,GAAaI,EA7CvB,0CA+Cd,EAAKM,4BAA4B7B,IA/CnB,YAgDZkB,IAAsBE,EAhDV,0CAkDd,EAAKU,0BAlDS,iCAqDhB5B,GArDgB,4CA5DsE,wDAoH/F2B,4BAA8B,SAAC7B,GAC7B,MAAO,CACLG,YAAa,GAAF,SAAM,EAAKyB,wBAAwB5B,GAASG,aAA5C,EAA4D,EAAK2B,yBAAyB3B,gBAtHV,EA0H/FyB,wBAA0B,SAAC5B,GAAyE,IAC1FC,EAAYD,EAAZC,QACFE,EAAc,GAEpB,GAAIF,GAAWA,EAAQK,OAAQ,CAC7B,IAAMyB,EAAeC,IAAEC,MAAMhC,GAC1BiC,KAAI,SAACC,GAAD,OAAOA,EAAEC,MAAMC,QACnBC,SACAC,OACAC,KA3LkB,GA4LlBN,IAAI3E,GACJ2E,KAAI,SAACO,GAAD,OAjLN,SAA4BA,EAAsBxC,GACvD,IAAMyC,EAAWC,KAAKC,MAZK,MAarBC,EAAiB5C,EAAQqC,QAAO,SAACH,GAAD,OAAOA,EAAEW,GAAKJ,GAAYP,EAAEC,QAAUK,EAAKjF,SAC3EuF,EAAQF,EAAevC,OACvB0C,EAASH,EAAe,GAC1BI,EAAO,WAAH,OAAcF,EAAd,2BAER,GAAIC,EAAQ,CACV,IAAME,EAAcC,mBAASH,EAAOF,IAAIM,UACxCH,EAAO,GAAH,OAAMA,EAAN,yBAA2BC,EAA3B,KAGN,YACKT,EADL,CAEEY,cAAeJ,IAmKIK,CAAmBb,EAAMxC,MACvCJ,QAEHM,EAAYoD,KAAK,CACfC,aAAa,EACbC,UAAU,EACVjG,MAAO,UACPkG,MAAO3B,IAIX,MAAO,CAAE5B,gBAhJoF,EAmJ/F2B,uBAAyB,WAAuB,WACtC7C,EADsC,EACtCA,QAASE,EAD6B,EAC7BA,gBACXgB,EAAc,GAQpB,GANAA,EAAYoD,KAAK,CACfC,aAAa,EACbhG,MAAO,YACPkG,MAAOC,IAAUzB,IAAIzE,KAGnBwB,GAAWA,EAAQqB,OAAQ,CAC7B,IAAMsD,EAAYC,YAAa5E,GAC/BkB,EAAYoD,KAAK,CACf/F,MAAO,UAAF,OAAYoG,GACjBF,MAAOI,YAAiB7E,GAASiD,KAAI,SAAC6B,GAAD,OA3L7C,SAA4BC,EAAgBC,GAC1C,IAAMxB,EAAuB,CAAEjF,MAAOwG,GACtC,GAAIC,GAAYA,EAASD,GAAS,OACTC,EAASD,GAAQ,GAAhCE,EADwB,EACxBA,KAAMC,EADkB,EAClBA,KACd1B,EAAKY,cAAL,UAAwBa,EAAKE,cAA7B,aAA+CD,GAEjD,OAAO1B,EAqL2C4B,CAAmBN,EAAG5E,QAItE,MAAO,CAAEgB,gBArKoF,EAoL/FwB,8BApL+F,4CAoL/D,WAAO9B,GAAP,+GACxBM,EAAqC,GAIrCmE,EAAYzE,EAAMQ,SAASkE,YAAYC,QAAO,SAAC5E,EAAc6E,GACjE,IAAKA,EACH,OAAO7E,EAGT,IAAM8E,EAAYD,aAAH,EAAGA,EAAO5D,UAQzB,OANIhB,EAAM8E,YAAYC,MAAQH,EAAMG,MAGlCC,EAAchF,EAAMY,UAAUM,OAAOC,OAASpB,EAAKU,QAG9CV,EAAO8E,IACb,IAGGI,EAA6BR,EAAUS,YAAY,IAAKF,GAC1DG,EAA0BV,EAAUS,YAAY,IAAKD,EAA6B,GAClFG,EAA2BX,EAAUY,QAAQ,IAAKF,IAGrB,IAA7BA,IACIG,EAA8Bb,EAAUY,QAAQ,IAAKL,GAC3DI,EAA2BX,EAAUY,QAAQ,IAAKC,EAA8B,GAChFH,EAA0BV,EAAUS,YAAY,IAAKE,IAGjDG,EAAS,CACbjF,cACAH,QAAS,wBAIsB,IAA7BgF,EAvC0B,yCAwCrBI,GAxCqB,cA4CxBC,EAAiBf,EACpB9E,MAAMwF,EAA0B,EAAGC,GACnCK,QAAQ,cAAe,IAEpBC,EAAWC,YAAcH,EAAgBA,EAAe/E,OAAS,GAAGiF,SAhD5C,UAkDJ,EAAKE,eAAeF,GAlDhB,eAkDxBG,EAlDwB,UAoDtB9B,EAAYC,YAAa6B,EAAY,IAC3CvF,EAAYoD,KAAK,CACf/F,MAAO,SAAF,OAAWoG,GAChBF,MAAOiC,OAAOC,KAAKF,GAAaxD,IAAI3E,MAvDV,kBA0DvB6H,GA1DuB,4CApL+D,wDAiP/F1D,wBAjP+F,4CAiPrE,uJACxB9B,EADwB,EACxBA,KACAG,EAFwB,EAExBA,eACAD,EAHwB,EAGxBA,SACAD,EAJwB,EAIxBA,MAJwB,yCAOf,CAAEM,YAAa,KAPA,UAUlBA,EAAqC,GACrC0F,EAAOhG,EAAM8E,YAAY9D,UACzBiF,EAAejG,EAAMY,UAAUM,OAAOC,OACtC+E,EAASF,EAAKG,OAAOF,GACrBnG,EAASkG,EAAKG,OAAO,EAAGF,GACxBG,EAAerG,EAAKyB,MAAM,iBAC1B6E,EAAaH,EAAO1E,MAAM,aAE1B8E,EAAaxG,EAAO0B,MAAM,kBAAoB0E,EAAO1E,MAAM,MAI3D+E,EAAiBF,IAAeD,GADjBA,GAAgBC,GAEdE,KAAmBD,EAvBlB,0CAwBf,CAAEhG,gBAxBa,QA8BxB,IACEkG,EAAiBb,YAAcK,EAAMC,GACrCP,EAAWc,EAAed,SAC1B,SACAA,EA5UiB,KA0SK,GAqClBe,EAAiBf,EAAS/D,SAAS,aACnC+E,EAAeF,EAAiBA,EAAeG,UAAY,IAI7DjB,EA1CoB,kCA2CF,EAAKE,eAAeF,GAAWe,GA3C7B,QA2CtBZ,EA3CsB,kBA8CnBA,EA9CmB,wBA+CtBjH,QAAQgI,KAAR,0DAAgElB,IA/C1C,kBAgDf,CAAEpF,gBAhDa,eAqDnBP,GAAQqG,GAAiBlG,EAAeyB,SAAS,cAEhD1B,GAAY4F,EAAY5F,KAC1BE,EAAU,uBACJ4D,EAAYC,YAAa6B,EAAY5F,IAC3CK,EAAYoD,KAAK,CACf/F,MAAO,qBAAF,OAAuBsC,EAAvB,YAAmC8D,GACxCF,MAAOgC,EAAY5F,GAAUoC,IAAI3E,OAK/BiJ,EAAYd,EAAcC,OAAOC,KAAKF,GAAeY,EAAiB,KAAOjJ,KAG3EqJ,EAAe1E,IAAE2E,WAAWH,EAAWD,IAC5BjG,SACfN,EAAU,iBACJ4G,EAAWF,EAAaxE,KAAI,SAAC0C,GAAD,MAAU,CAAEpH,MAAOoH,MAC/ChB,EAAYC,YAAa+C,GACzBC,EAAqC,CAAErJ,MAAO,SAAF,OAAWoG,GAAaF,MAAOkD,GACjFzG,EAAYoD,KAAKsD,IA1EC,kBA+EjB,CAAE7G,UAASG,gBA/EM,4CAjPqE,wDAoV/F2G,iBApV+F,4CAoV5E,WAAOlC,GAAP,mGACX/F,EAAS,EAAKf,WAAWgB,eACzBT,EAAS,CACbM,MAAOE,EAAM,MAAUE,WACvBC,IAAKH,EAAM,IAAQE,YAEfZ,EANW,wBAMYyG,EANZ,oBAOE,EAAK1G,QAAQC,EAAK,GAAIE,GAPxB,cAOXG,EAPW,8BAQPoG,EAAMpG,IARC,2CApV4E,wDAqW/FuI,kBArW+F,4CAqW3E,WAAOC,EAAcC,GAArB,uGACZpI,EAAS,EAAKf,WAAWgB,eACzBoI,EAAY,CAChB,UAAWF,EACXrI,MAAOE,EAAM,MAAUE,WACvBC,IAAKH,EAAM,IAAQE,YALH,iBAYZoI,EAAc,IAAIC,gBAAgB,CACtC,UAAWJ,EACXrI,MAAO0I,YAAcxI,EAAM,OAAWE,WACtCC,IAAKqI,YAAcxI,EAAM,KAASE,WAClCkI,SAAUA,EAAW,OAAS,UAG1BK,EAnBY,yBAmBiBH,EAAYpI,YAC3Cc,EAAQ,EAAK7B,YAAYuJ,IAAID,GApBf,iCAsBG,EAAKpJ,QAtBR,iBAsBqB,GAAIgJ,GAtBzB,OAsBV1I,EAtBU,SAuBGgJ,YAAchJ,EAAMyI,GAA/B5H,EAvBQ,EAuBRA,OACRQ,EAAQR,EACR,EAAKrB,YAAYyJ,IAAIH,EAAUzH,GAzBf,iCA2BXA,GA3BW,4CArW2E,0DAwY/F6H,mBAAqB1F,IAAE2F,KAAF,2BAAO,mHACLC,QAAQC,IAAIxK,EAAa6E,KAAI,SAAC0C,GAAD,OAAS,EAAKkC,iBAAiBlC,OADvD,cACpBvF,EADoB,yBAEnBA,EAAOmF,QAAO,SAACsD,EAAKjI,GAAN,YAAsBiI,EAAtB,GAA8BjI,KAAU,KAFnC,4CArY1B,EAAK/B,WAAaA,EAClB,EAAKyB,iBAAmB,GACxB,EAAKwI,UAAY,CAAEpJ,MAAO,EAAGK,IAAK,GAClC,EAAKC,QAAU,GAEf0G,OAAOqC,OAAP,KAAoBjK,GARyE,E,mSAYrFkK,GAGR,OAFcA,EAAEC,MAAMtK,GACHuK,MACPC,WAAW9C,QAAQ,KAAM,IAAIA,QAAQ,KAAM,M,gDA0JvD,MAAO,CACLtF,QAAS,gBACTG,YAAa,CACX,CACE3C,MAAO,eACPkG,MAAO,EAAI2E,U,qEAqJE9C,EAAkB0B,G,oFACjCqB,KAAKxK,WAAWc,gB,8CACX2J,G,mBA9XU,OAiYbhD,E,gCACW+C,KAAKZ,qB,gEAELY,KAAKvB,kBAAkBxB,EAAU0B,G,0GAIhDxI,QAAQC,MAAR,M,uBACO6J,G,uIA7TT,OAAOC,S,8BAlCyCC,qB,oCC/DpDC,EAAOC,QAAU,SAAUC,GACzBA,EAAQC,UAAUC,OAAOC,UAAzB,yBAAqC,mGAC1BC,EAASV,KAAKW,KADY,WACND,EADM,gBAEjC,OAFiC,SAE3BA,EAAOnJ,MAFoB,OACEmJ,EAASA,EAAOE,KADlB,gE,kCCIvC,SAASN,EAASO,GAChB,IAAIC,EAAOd,KASX,GARMc,aAAgBR,IACpBQ,EAAO,IAAIR,GAGbQ,EAAKC,KAAO,KACZD,EAAKH,KAAO,KACZG,EAAK9I,OAAS,EAEV6I,GAAgC,mBAAjBA,EAAKG,QACtBH,EAAKG,SAAQ,SAAU7G,GACrB2G,EAAK7F,KAAKd,WAEP,GAAI8G,UAAUjJ,OAAS,EAC5B,IAAK,IAAIkJ,EAAI,EAAGC,EAAIF,UAAUjJ,OAAQkJ,EAAIC,EAAGD,IAC3CJ,EAAK7F,KAAKgG,UAAUC,IAIxB,OAAOJ,EAoVT,SAASM,EAAQN,EAAMO,EAAM9J,GAC3B,IAAI+J,EAAWD,IAASP,EAAKH,KAC3B,IAAIY,EAAKhK,EAAO,KAAM8J,EAAMP,GAC5B,IAAIS,EAAKhK,EAAO8J,EAAMA,EAAKT,KAAME,GAWnC,OATsB,OAAlBQ,EAASV,OACXE,EAAKC,KAAOO,GAEQ,OAAlBA,EAASE,OACXV,EAAKH,KAAOW,GAGdR,EAAK9I,SAEEsJ,EAGT,SAASrG,EAAM6F,EAAM3G,GACnB2G,EAAKC,KAAO,IAAIQ,EAAKpH,EAAM2G,EAAKC,KAAM,KAAMD,GACvCA,EAAKH,OACRG,EAAKH,KAAOG,EAAKC,MAEnBD,EAAK9I,SAGP,SAASyJ,EAASX,EAAM3G,GACtB2G,EAAKH,KAAO,IAAIY,EAAKpH,EAAM,KAAM2G,EAAKH,KAAMG,GACvCA,EAAKC,OACRD,EAAKC,KAAOD,EAAKH,MAEnBG,EAAK9I,SAGP,SAASuJ,EAAMhK,EAAOiK,EAAMZ,EAAMC,GAChC,KAAMb,gBAAgBuB,GACpB,OAAO,IAAIA,EAAKhK,EAAOiK,EAAMZ,EAAMC,GAGrCb,KAAKa,KAAOA,EACZb,KAAKzI,MAAQA,EAETiK,GACFA,EAAKZ,KAAOZ,KACZA,KAAKwB,KAAOA,GAEZxB,KAAKwB,KAAO,KAGVZ,GACFA,EAAKY,KAAOxB,KACZA,KAAKY,KAAOA,GAEZZ,KAAKY,KAAO,KAjahBR,EAAOC,QAAUC,EAEjBA,EAAQiB,KAAOA,EACfjB,EAAQoB,OAASpB,EAyBjBA,EAAQC,UAAUoB,WAAa,SAAUN,GACvC,GAAIA,EAAKR,OAASb,KAChB,MAAM,IAAI4B,MAAM,oDAGlB,IAAIhB,EAAOS,EAAKT,KACZY,EAAOH,EAAKG,KAsBhB,OApBIZ,IACFA,EAAKY,KAAOA,GAGVA,IACFA,EAAKZ,KAAOA,GAGVS,IAASrB,KAAKW,OAChBX,KAAKW,KAAOC,GAEVS,IAASrB,KAAKe,OAChBf,KAAKe,KAAOS,GAGdH,EAAKR,KAAK7I,SACVqJ,EAAKT,KAAO,KACZS,EAAKG,KAAO,KACZH,EAAKR,KAAO,KAELD,GAGTN,EAAQC,UAAUsB,YAAc,SAAUR,GACxC,GAAIA,IAASrB,KAAKW,KAAlB,CAIIU,EAAKR,MACPQ,EAAKR,KAAKc,WAAWN,GAGvB,IAAIV,EAAOX,KAAKW,KAChBU,EAAKR,KAAOb,KACZqB,EAAKT,KAAOD,EACRA,IACFA,EAAKa,KAAOH,GAGdrB,KAAKW,KAAOU,EACPrB,KAAKe,OACRf,KAAKe,KAAOM,GAEdrB,KAAKhI,WAGPsI,EAAQC,UAAUuB,SAAW,SAAUT,GACrC,GAAIA,IAASrB,KAAKe,KAAlB,CAIIM,EAAKR,MACPQ,EAAKR,KAAKc,WAAWN,GAGvB,IAAIN,EAAOf,KAAKe,KAChBM,EAAKR,KAAOb,KACZqB,EAAKG,KAAOT,EACRA,IACFA,EAAKH,KAAOS,GAGdrB,KAAKe,KAAOM,EACPrB,KAAKW,OACRX,KAAKW,KAAOU,GAEdrB,KAAKhI,WAGPsI,EAAQC,UAAUtF,KAAO,WACvB,IAAK,IAAIiG,EAAI,EAAGC,EAAIF,UAAUjJ,OAAQkJ,EAAIC,EAAGD,IAC3CjG,EAAK+E,KAAMiB,UAAUC,IAEvB,OAAOlB,KAAKhI,QAGdsI,EAAQC,UAAUkB,QAAU,WAC1B,IAAK,IAAIP,EAAI,EAAGC,EAAIF,UAAUjJ,OAAQkJ,EAAIC,EAAGD,IAC3CO,EAAQzB,KAAMiB,UAAUC,IAE1B,OAAOlB,KAAKhI,QAGdsI,EAAQC,UAAUV,IAAM,WACtB,GAAKG,KAAKe,KAAV,CAIA,IAAI9K,EAAM+J,KAAKe,KAAKxJ,MAQpB,OAPAyI,KAAKe,KAAOf,KAAKe,KAAKS,KAClBxB,KAAKe,KACPf,KAAKe,KAAKH,KAAO,KAEjBZ,KAAKW,KAAO,KAEdX,KAAKhI,SACE/B,IAGTqK,EAAQC,UAAUwB,MAAQ,WACxB,GAAK/B,KAAKW,KAAV,CAIA,IAAI1K,EAAM+J,KAAKW,KAAKpJ,MAQpB,OAPAyI,KAAKW,KAAOX,KAAKW,KAAKC,KAClBZ,KAAKW,KACPX,KAAKW,KAAKa,KAAO,KAEjBxB,KAAKe,KAAO,KAEdf,KAAKhI,SACE/B,IAGTqK,EAAQC,UAAUS,QAAU,SAAUgB,EAAIC,GACxCA,EAAQA,GAASjC,KACjB,IAAK,IAAIU,EAASV,KAAKW,KAAMO,EAAI,EAAc,OAAXR,EAAiBQ,IACnDc,EAAGE,KAAKD,EAAOvB,EAAOnJ,MAAO2J,EAAGlB,MAChCU,EAASA,EAAOE,MAIpBN,EAAQC,UAAU4B,eAAiB,SAAUH,EAAIC,GAC/CA,EAAQA,GAASjC,KACjB,IAAK,IAAIU,EAASV,KAAKe,KAAMG,EAAIlB,KAAKhI,OAAS,EAAc,OAAX0I,EAAiBQ,IACjEc,EAAGE,KAAKD,EAAOvB,EAAOnJ,MAAO2J,EAAGlB,MAChCU,EAASA,EAAOc,MAIpBlB,EAAQC,UAAUtB,IAAM,SAAUmD,GAChC,IAAK,IAAIlB,EAAI,EAAGR,EAASV,KAAKW,KAAiB,OAAXD,GAAmBQ,EAAIkB,EAAGlB,IAE5DR,EAASA,EAAOE,KAElB,GAAIM,IAAMkB,GAAgB,OAAX1B,EACb,OAAOA,EAAOnJ,OAIlB+I,EAAQC,UAAU8B,WAAa,SAAUD,GACvC,IAAK,IAAIlB,EAAI,EAAGR,EAASV,KAAKe,KAAiB,OAAXL,GAAmBQ,EAAIkB,EAAGlB,IAE5DR,EAASA,EAAOc,KAElB,GAAIN,IAAMkB,GAAgB,OAAX1B,EACb,OAAOA,EAAOnJ,OAIlB+I,EAAQC,UAAU3G,IAAM,SAAUoI,EAAIC,GACpCA,EAAQA,GAASjC,KAEjB,IADA,IAAI/J,EAAM,IAAIqK,EACLI,EAASV,KAAKW,KAAiB,OAAXD,GAC3BzK,EAAIgF,KAAK+G,EAAGE,KAAKD,EAAOvB,EAAOnJ,MAAOyI,OACtCU,EAASA,EAAOE,KAElB,OAAO3K,GAGTqK,EAAQC,UAAU+B,WAAa,SAAUN,EAAIC,GAC3CA,EAAQA,GAASjC,KAEjB,IADA,IAAI/J,EAAM,IAAIqK,EACLI,EAASV,KAAKe,KAAiB,OAAXL,GAC3BzK,EAAIgF,KAAK+G,EAAGE,KAAKD,EAAOvB,EAAOnJ,MAAOyI,OACtCU,EAASA,EAAOc,KAElB,OAAOvL,GAGTqK,EAAQC,UAAUrE,OAAS,SAAU8F,EAAIO,GACvC,IAAI/C,EACAkB,EAASV,KAAKW,KAClB,GAAIM,UAAUjJ,OAAS,EACrBwH,EAAM+C,MACD,KAAIvC,KAAKW,KAId,MAAM,IAAI6B,UAAU,8CAHpB9B,EAASV,KAAKW,KAAKC,KACnBpB,EAAMQ,KAAKW,KAAKpJ,MAKlB,IAAK,IAAI2J,EAAI,EAAc,OAAXR,EAAiBQ,IAC/B1B,EAAMwC,EAAGxC,EAAKkB,EAAOnJ,MAAO2J,GAC5BR,EAASA,EAAOE,KAGlB,OAAOpB,GAGTc,EAAQC,UAAUkC,cAAgB,SAAUT,EAAIO,GAC9C,IAAI/C,EACAkB,EAASV,KAAKe,KAClB,GAAIE,UAAUjJ,OAAS,EACrBwH,EAAM+C,MACD,KAAIvC,KAAKe,KAId,MAAM,IAAIyB,UAAU,8CAHpB9B,EAASV,KAAKe,KAAKS,KACnBhC,EAAMQ,KAAKe,KAAKxJ,MAKlB,IAAK,IAAI2J,EAAIlB,KAAKhI,OAAS,EAAc,OAAX0I,EAAiBQ,IAC7C1B,EAAMwC,EAAGxC,EAAKkB,EAAOnJ,MAAO2J,GAC5BR,EAASA,EAAOc,KAGlB,OAAOhC,GAGTc,EAAQC,UAAUmC,QAAU,WAE1B,IADA,IAAIC,EAAM,IAAIC,MAAM5C,KAAKhI,QAChBkJ,EAAI,EAAGR,EAASV,KAAKW,KAAiB,OAAXD,EAAiBQ,IACnDyB,EAAIzB,GAAKR,EAAOnJ,MAChBmJ,EAASA,EAAOE,KAElB,OAAO+B,GAGTrC,EAAQC,UAAUsC,eAAiB,WAEjC,IADA,IAAIF,EAAM,IAAIC,MAAM5C,KAAKhI,QAChBkJ,EAAI,EAAGR,EAASV,KAAKe,KAAiB,OAAXL,EAAiBQ,IACnDyB,EAAIzB,GAAKR,EAAOnJ,MAChBmJ,EAASA,EAAOc,KAElB,OAAOmB,GAGTrC,EAAQC,UAAUrJ,MAAQ,SAAU4L,EAAMC,IACxCA,EAAKA,GAAM/C,KAAKhI,QACP,IACP+K,GAAM/C,KAAKhI,SAEb8K,EAAOA,GAAQ,GACJ,IACTA,GAAQ9C,KAAKhI,QAEf,IAAIgL,EAAM,IAAI1C,EACd,GAAIyC,EAAKD,GAAQC,EAAK,EACpB,OAAOC,EAELF,EAAO,IACTA,EAAO,GAELC,EAAK/C,KAAKhI,SACZ+K,EAAK/C,KAAKhI,QAEZ,IAAK,IAAIkJ,EAAI,EAAGR,EAASV,KAAKW,KAAiB,OAAXD,GAAmBQ,EAAI4B,EAAM5B,IAC/DR,EAASA,EAAOE,KAElB,KAAkB,OAAXF,GAAmBQ,EAAI6B,EAAI7B,IAAKR,EAASA,EAAOE,KACrDoC,EAAI/H,KAAKyF,EAAOnJ,OAElB,OAAOyL,GAGT1C,EAAQC,UAAU0C,aAAe,SAAUH,EAAMC,IAC/CA,EAAKA,GAAM/C,KAAKhI,QACP,IACP+K,GAAM/C,KAAKhI,SAEb8K,EAAOA,GAAQ,GACJ,IACTA,GAAQ9C,KAAKhI,QAEf,IAAIgL,EAAM,IAAI1C,EACd,GAAIyC,EAAKD,GAAQC,EAAK,EACpB,OAAOC,EAELF,EAAO,IACTA,EAAO,GAELC,EAAK/C,KAAKhI,SACZ+K,EAAK/C,KAAKhI,QAEZ,IAAK,IAAIkJ,EAAIlB,KAAKhI,OAAQ0I,EAASV,KAAKe,KAAiB,OAAXL,GAAmBQ,EAAI6B,EAAI7B,IACvER,EAASA,EAAOc,KAElB,KAAkB,OAAXd,GAAmBQ,EAAI4B,EAAM5B,IAAKR,EAASA,EAAOc,KACvDwB,EAAI/H,KAAKyF,EAAOnJ,OAElB,OAAOyL,GAGT1C,EAAQC,UAAU2C,OAAS,SAAU7M,EAAO8M,GACtC9M,EAAQ2J,KAAKhI,SACf3B,EAAQ2J,KAAKhI,OAAS,GAEpB3B,EAAQ,IACVA,EAAQ2J,KAAKhI,OAAS3B,GAGxB,IAAK,IAAI6K,EAAI,EAAGR,EAASV,KAAKW,KAAiB,OAAXD,GAAmBQ,EAAI7K,EAAO6K,IAChER,EAASA,EAAOE,KAGlB,IAAIoC,EAAM,GACV,IAAS9B,EAAI,EAAGR,GAAUQ,EAAIiC,EAAajC,IACzC8B,EAAI/H,KAAKyF,EAAOnJ,OAChBmJ,EAASV,KAAK2B,WAAWjB,GAEZ,OAAXA,IACFA,EAASV,KAAKe,MAGZL,IAAWV,KAAKW,MAAQD,IAAWV,KAAKe,OAC1CL,EAASA,EAAOc,MAGlB,IAASN,EAAI,EAAGA,EAAID,UAAUjJ,OAAQkJ,IACpCR,EAASU,EAAOpB,KAAMU,EAAQO,UAAUC,IAE1C,OAAO8B,GAGT1C,EAAQC,UAAU6C,QAAU,WAG1B,IAFA,IAAIzC,EAAOX,KAAKW,KACZI,EAAOf,KAAKe,KACPL,EAASC,EAAiB,OAAXD,EAAiBA,EAASA,EAAOc,KAAM,CAC7D,IAAI6B,EAAI3C,EAAOc,KACfd,EAAOc,KAAOd,EAAOE,KACrBF,EAAOE,KAAOyC,EAIhB,OAFArD,KAAKW,KAAOI,EACZf,KAAKe,KAAOJ,EACLX,MA2DT,IAEEsD,EAAQ,OAARA,CAAyBhD,GACzB,MAAOiD,M,sSCtaT,IAAMjD,EAAUgD,EAAQ,QAElBE,EAAMhD,OAAO,OACbiD,EAASjD,OAAO,UAChBkD,EAAoBlD,OAAO,oBAC3BmD,EAAcnD,OAAO,cACrBoD,EAAUpD,OAAO,UACjBqD,EAAUrD,OAAO,WACjBsD,EAAoBtD,OAAO,kBAC3BuD,EAAWvD,OAAO,WAClBwD,EAAQxD,OAAO,SACfyD,EAAoBzD,OAAO,kBAE3B0D,EAAc,kBAAM,GAUpBC,E,WACJ,WAAaC,GAOX,GAPoB,UACG,iBAAZA,IACTA,EAAU,CAAEC,IAAKD,IAEdA,IACHA,EAAU,IAERA,EAAQC,MAA+B,iBAAhBD,EAAQC,KAAoBD,EAAQC,IAAM,GACnE,MAAM,IAAI7B,UAAU,qCAEVxC,KAAKwD,GAAOY,EAAQC,KAAOC,IAAvC,IAEMC,EAAKH,EAAQpM,QAAUkM,EAG7B,GAFAlE,KAAK0D,GAAoC,mBAAPa,EAAqBL,EAAcK,EACrEvE,KAAK2D,GAAeS,EAAQI,QAAS,EACjCJ,EAAQK,QAAoC,iBAAnBL,EAAQK,OACnC,MAAM,IAAIjC,UAAU,2BACtBxC,KAAK4D,GAAWQ,EAAQK,QAAU,EAClCzE,KAAK6D,GAAWO,EAAQM,QACxB1E,KAAK8D,GAAqBM,EAAQO,iBAAkB,EACpD3E,KAAKiE,GAAqBG,EAAQQ,iBAAkB,EACpD5E,KAAK6E,Q,wDAqDG7C,EAAIC,GACZA,EAAQA,GAASjC,KACjB,IAAK,IAAIU,EAASV,KAAK+D,GAAUhD,KAAiB,OAAXL,GAAkB,CACvD,IAAMc,EAAOd,EAAOc,KACpBsD,EAAY9E,KAAMgC,EAAItB,EAAQuB,GAC9BvB,EAASc,K,8BAIJQ,EAAIC,GACXA,EAAQA,GAASjC,KACjB,IAAK,IAAIU,EAASV,KAAK+D,GAAUpD,KAAiB,OAAXD,GAAkB,CACvD,IAAME,EAAOF,EAAOE,KACpBkE,EAAY9E,KAAMgC,EAAItB,EAAQuB,GAC9BvB,EAASE,K,6BAKX,OAAOZ,KAAK+D,GAAUrB,UAAU9I,KAAI,SAAAmL,GAAC,OAAIA,EAAEzI,S,+BAI3C,OAAO0D,KAAK+D,GAAUrB,UAAU9I,KAAI,SAAAmL,GAAC,OAAIA,EAAExN,W,8BAGpC,WACHyI,KAAK6D,IACL7D,KAAK+D,IACL/D,KAAK+D,GAAU/L,QACjBgI,KAAK+D,GAAU/C,SAAQ,SAAAgE,GAAG,OAAI,EAAKnB,GAASmB,EAAI1I,IAAK0I,EAAIzN,UAG3DyI,KAAKgE,GAAS,IAAIiB,IAClBjF,KAAK+D,GAAY,IAAIzD,EACrBN,KAAKyD,GAAU,I,6BAGT,WACN,OAAOzD,KAAK+D,GAAUnK,KAAI,SAAAoL,GAAG,OAC3BE,EAAQ,EAAMF,IAAe,CAC3BD,EAAGC,EAAI1I,IACP6I,EAAGH,EAAIzN,MACP6N,EAAGJ,EAAI1K,KAAO0K,EAAIP,QAAU,OAC3B/B,UAAU1I,QAAO,SAAAH,GAAC,OAAIA,O,gCAI3B,OAAOmG,KAAK+D,K,0BAGTzH,EAAK/E,EAAOkN,GAGf,IAFAA,EAASA,GAAUzE,KAAK4D,KAEQ,iBAAXa,EACnB,MAAM,IAAIjC,UAAU,2BAEtB,IAAMlI,EAAMmK,EAASpK,KAAKC,MAAQ,EAC5B+K,EAAMrF,KAAK0D,GAAmBnM,EAAO+E,GAE3C,GAAI0D,KAAKgE,GAAOsB,IAAIhJ,GAAM,CACxB,GAAI+I,EAAMrF,KAAKwD,GAEb,OADA+B,EAAIvF,KAAMA,KAAKgE,GAAO/E,IAAI3C,KACnB,EAGT,IACMnC,EADO6F,KAAKgE,GAAO/E,IAAI3C,GACX/E,MAgBlB,OAZIyI,KAAK6D,KACF7D,KAAK8D,IACR9D,KAAK6D,GAASvH,EAAKnC,EAAK5C,QAG5B4C,EAAKG,IAAMA,EACXH,EAAKsK,OAASA,EACdtK,EAAK5C,MAAQA,EACbyI,KAAKyD,IAAW4B,EAAMlL,EAAKnC,OAC3BmC,EAAKnC,OAASqN,EACdrF,KAAKf,IAAI3C,GACTkJ,EAAKxF,OACE,EAGT,IAAMgF,EAAM,IAAIS,EAAMnJ,EAAK/E,EAAO8N,EAAK/K,EAAKmK,GAG5C,OAAIO,EAAIhN,OAASgI,KAAKwD,IAChBxD,KAAK6D,IACP7D,KAAK6D,GAASvH,EAAK/E,IAEd,IAGTyI,KAAKyD,IAAWuB,EAAIhN,OACpBgI,KAAK+D,GAAUtC,QAAQuD,GACvBhF,KAAKgE,GAAO7E,IAAI7C,EAAK0D,KAAK+D,GAAUpD,MACpC6E,EAAKxF,OACE,K,0BAGJ1D,GACH,IAAK0D,KAAKgE,GAAOsB,IAAIhJ,GAAM,OAAO,EAClC,IAAM0I,EAAMhF,KAAKgE,GAAO/E,IAAI3C,GAAK/E,MACjC,OAAQ2N,EAAQlF,KAAMgF,K,0BAGnB1I,GACH,OAAO2C,EAAIe,KAAM1D,GAAK,K,2BAGlBA,GACJ,OAAO2C,EAAIe,KAAM1D,GAAK,K,4BAItB,IAAM+E,EAAOrB,KAAK+D,GAAUhD,KAC5B,OAAKM,GAGLkE,EAAIvF,KAAMqB,GACHA,EAAK9J,OAHH,O,0BAMN+E,GACHiJ,EAAIvF,KAAMA,KAAKgE,GAAO/E,IAAI3C,M,2BAGtBqG,GAEJ3C,KAAK6E,QAIL,IAFA,IAAMvK,EAAMD,KAAKC,MAER6G,EAAIwB,EAAI3K,OAAS,EAAGmJ,GAAK,EAAGA,IAAK,CACxC,IAAM6D,EAAMrC,EAAIxB,GACVuE,EAAYV,EAAII,GAAK,EAC3B,GAAkB,IAAdM,EAEF1F,KAAKb,IAAI6F,EAAID,EAAGC,EAAIG,OACjB,CACH,IAAMV,EAASiB,EAAYpL,EAEvBmK,EAAS,GACXzE,KAAKb,IAAI6F,EAAID,EAAGC,EAAIG,EAAGV,O,8BAMtB,WACPzE,KAAKgE,GAAOhD,SAAQ,SAACzJ,EAAO+E,GAAR,OAAgB2C,EAAI,EAAM3C,GAAK,Q,wBA1M5CqJ,GACP,GAAkB,iBAAPA,GAAmBA,EAAK,EACjC,MAAM,IAAInD,UAAU,qCAEtBxC,KAAKwD,GAAOmC,GAAMrB,IAClBkB,EAAKxF,O,eAGL,OAAOA,KAAKwD,K,+BAGEoC,GACd5F,KAAK2D,KAAiBiC,G,eAGtB,OAAO5F,KAAK2D,K,2BAGFkC,GACV,GAAkB,iBAAPA,EACT,MAAM,IAAIrD,UAAU,wCAEtBxC,KAAK4D,GAAWiC,EAChBL,EAAKxF,O,eAGL,OAAOA,KAAK4D,K,qCAIQkC,GAAI,WACN,mBAAPA,IACTA,EAAK5B,GAEH4B,IAAO9F,KAAK0D,KACd1D,KAAK0D,GAAqBoC,EAC1B9F,KAAKyD,GAAU,EACfzD,KAAK+D,GAAU/C,SAAQ,SAAAgE,GACrBA,EAAIhN,OAAS,EAAK0L,GAAmBsB,EAAIzN,MAAOyN,EAAI1I,KACpD,EAAKmH,IAAWuB,EAAIhN,WAGxBwN,EAAKxF,O,eAEmB,OAAOA,KAAK0D,K,6BAEtB,OAAO1D,KAAKyD,K,gCACT,OAAOzD,KAAK+D,GAAU/L,Y,gCA+JrCiH,EAAM,SAAC6B,EAAMxE,EAAKyJ,GACtB,IAAM1E,EAAOP,EAAKkD,GAAO/E,IAAI3C,GAC7B,GAAI+E,EAAM,CACR,IAAM2D,EAAM3D,EAAK9J,MACjB,GAAI2N,EAAQpE,EAAMkE,IAEhB,GADAO,EAAIzE,EAAMO,IACLP,EAAK6C,GACR,YAEEoC,IACEjF,EAAKmD,KACP5C,EAAK9J,MAAM+C,IAAMD,KAAKC,OACxBwG,EAAKiD,GAAUlC,YAAYR,IAG/B,OAAO2D,EAAIzN,QAIT2N,EAAU,SAACpE,EAAMkE,GACrB,IAAKA,IAASA,EAAIP,SAAW3D,EAAK8C,GAChC,OAAO,EAET,IAAMoC,EAAO3L,KAAKC,MAAQ0K,EAAI1K,IAC9B,OAAO0K,EAAIP,OAASuB,EAAOhB,EAAIP,OAC3B3D,EAAK8C,IAAaoC,EAAOlF,EAAK8C,IAG9B4B,EAAO,SAAA1E,GACX,GAAIA,EAAK2C,GAAU3C,EAAK0C,GACtB,IAAK,IAAI9C,EAASI,EAAKiD,GAAUhD,KAC/BD,EAAK2C,GAAU3C,EAAK0C,IAAmB,OAAX9C,GAAkB,CAI9C,IAAMc,EAAOd,EAAOc,KACpB+D,EAAIzE,EAAMJ,GACVA,EAASc,IAKT+D,EAAM,SAACzE,EAAMO,GACjB,GAAIA,EAAM,CACR,IAAM2D,EAAM3D,EAAK9J,MACbuJ,EAAK+C,IACP/C,EAAK+C,GAASmB,EAAI1I,IAAK0I,EAAIzN,OAE7BuJ,EAAK2C,IAAWuB,EAAIhN,OACpB8I,EAAKkD,GAAL,OAAmBgB,EAAI1I,KACvBwE,EAAKiD,GAAUpC,WAAWN,KAIxBoE,EACJ,WAAanJ,EAAK/E,EAAOS,EAAQsC,EAAKmK,GAAQ,UAC5CzE,KAAK1D,IAAMA,EACX0D,KAAKzI,MAAQA,EACbyI,KAAKhI,OAASA,EACdgI,KAAK1F,IAAMA,EACX0F,KAAKyE,OAASA,GAAU,GAItBK,EAAc,SAAChE,EAAMkB,EAAIX,EAAMY,GACnC,IAAI+C,EAAM3D,EAAK9J,MACX2N,EAAQpE,EAAMkE,KAChBO,EAAIzE,EAAMO,GACLP,EAAK6C,KACRqB,OAAM/E,IAEN+E,GACFhD,EAAGE,KAAKD,EAAO+C,EAAIzN,MAAOyN,EAAI1I,IAAKwE,IAGvCV,EAAOC,QAAU8D,G,m9CCzUV,IAEMnN,EAAyB,SAACiP,GAGrC,IAFA,IAAMC,EAAyB,IAAIC,IAC7BC,EAAS,IAAIC,OAAO,gBACjBC,EAAQ,EAAGA,EAAQL,EAAOjO,OAAQsO,IAAS,CAClD,IAAMpR,EAAQ+Q,EAAOK,GACIF,EAAOG,KAAKrR,IAEnCgR,EAAUM,IAAItR,GAKlB,MAAO,CAAE6B,OAAQ,CAAE0P,SAFJ,EAAIP,MAKd,SAAShH,EAAc+G,GAA4D,IAAlBtH,EAAkB,wDAGlF+H,EAA2C,GACjDT,EAAOjF,SAAQ,SAAC9L,GAAU,IAChBuR,EAAsBvR,EAAtBuR,SAAaE,EADG,EACMzR,EADN,cAEpByJ,IACF+H,EAAQ,SAAeA,EAAQ,UAAgB,IAAIP,IAC9CO,EAAQ,SAAapB,IAAImB,IAC5BC,EAAQ,SAAaF,IAAIC,IAI7BpJ,OAAOC,KAAKqJ,GAAM3F,SAAQ,SAAC1E,GACpBoK,EAASpK,KACZoK,EAASpK,GAAO,IAAI6J,KAEjBO,EAASpK,GAAKgJ,IAAIqB,EAAKrK,KAC1BoK,EAASpK,GAAKkK,IAAIG,EAAKrK,UAM7B,IAAMsK,EAA0C,GAKhD,OAJApL,EAAiB6B,OAAOC,KAAKoJ,IAAW1F,SAAQ,SAAC1E,GAC/CsK,EAAWtK,GAAOd,EAAiBoH,MAAME,KAAK4D,EAASpK,QAGlD,CAAEvF,OAAQ6P,EAAYtJ,KAAMD,OAAOC,KAAKsJ,IAI1C,IAAMC,EAAiB,iBACjBC,EAAc,8BACpB,SAAS5J,EAAcpD,GAAyE,IAA1D0D,EAA0D,uDAA3C,EAC1D,IAAK1D,EAAMf,MAAM8N,GAAiB,CAEhC,GAAI/M,EAAMf,MAAM,qBACd,MAAO,CACLkE,SAAU,cAAF,OAAgBnD,EAAhB,MACRoE,UAAW,CAAC,aAGhB,MAAM,IAAI0D,MAAM,kCAAoC9H,GAItD,IAAMzC,EAASyC,EAAM5C,MAAM,EAAGsG,GACxBuJ,EAAa1P,EAAOoF,YAAY,KAChCuK,EAAc3P,EAAOoF,YAAY,KACvC,IAAoB,IAAhBsK,EACF,MAAM,IAAInF,MAAM,4CAA8CvK,GAEhE,GAAI2P,GAAe,GAAKA,EAAcD,EACpC,MAAM,IAAInF,MAAM,0DAA4DvK,GAE9E,IAAMoG,EAAS3D,EAAM5C,MAAMsG,GACrByJ,EAAmBxJ,EAAOb,QAAQ,KAClCsK,EAAcD,EAAmBzJ,EACjC2J,EAAkB1J,EAAOb,QAAQ,KACjCwK,EAAaD,EAAkB3J,EACrC,IAAqB,IAAjB0J,EACF,MAAM,IAAItF,MAAM,yDAA2DnE,GAE7E,GAAI0J,GAAmB,GAAKC,EAAaF,EACvC,MAAM,IAAItF,MAAM,oEAAsEnE,GAIxF,IAAMR,EAAWnD,EAAM5C,MAAM6P,EAAYG,GACnCjB,EAAiE,GACvEhJ,EAASD,QAAQ8J,GAAa,SAAC5R,EAAOoH,EAAK+K,EAAU9P,GACnD,IAAM+P,EAAcxN,EAAM8C,QAAQ1H,GAC5BqS,EAAaD,EAAchL,EAAItE,OAASqP,EAASrP,OAAS,EAC1DwP,EAAWF,EAAchL,EAAItE,OAASqP,EAASrP,OAAST,EAAMS,OAAS,EAK7E,OAHIwF,EAAe+J,GAAc/J,EAAegK,KAC9CvB,EAAO3J,GAAO,CAAE/E,QAAO8P,aAElB,MAIT,IAAMI,EAAe3N,EAAM5C,MAAM,EAAG6P,GAC9BW,EAAcD,EAAa1O,MAAM,oBACnC2O,IACFzB,EAAM,SAAe,CAAE1O,MAAO,IAAF,OAAMmQ,EAAY,GAAlB,KAAyBL,SAAU,MAIjE,IAAMnJ,EAAYb,OAAOC,KAAK2I,GAAQ9O,OAChCwQ,EAAgBzJ,EAAUtE,KAAI,SAAC0C,GAAD,gBAAYA,GAAZ,OAAkB2J,EAAO3J,GAAK+K,UAA9B,OAAyCpB,EAAO3J,GAAK/E,UAASqQ,KAAK,KAEjG7K,EAAiB,CAAC,IAAK4K,EAAe,KAAKC,KAAK,IAEtD,MAAO,CAAE1J,YAAWjB,SAAUF,GAGzB,SAAS8K,EAAqB/N,EAAegO,GAClD,IAAMC,EAAY1K,OAAOC,KAAKwK,GACxBE,EAAa,IAAI3B,OAAJ,kBAAsB0B,EAAUH,KAAK,KAArC,wBAAiE,MAI9EK,EAHgBnO,EAAMkD,QAAQgL,GAAY,SAACjP,EAAOmP,EAAKxJ,EAAMyJ,GAAnB,gBAA+BD,GAA/B,OAAqCJ,EAAQpJ,IAA7C,OAAqDyJ,MAGpEvI,MAAM,uBAGjCwI,EAAqB,mBAK3B,OAJoCH,EAAWrO,KAAI,SAACE,GAClD,OAMJ,SAA+BC,EAAcsO,GAA6B,MAClEtP,EAAQgB,EAAKhB,MAAMsP,GACzB,IAAKtP,EACH,OAAOgB,EAIT,IAAMuO,EAAiB,UAAGvP,EAAMuN,aAAT,QAAkB,EACnCiC,EAAuBxO,EAAK2D,OAAO,EAAG4K,EAAoB,GAC1DE,EAAsBzO,EAAK2D,OAAO4K,EAAoB,GAGtDG,EAA+E,GACrFD,EAAoBxL,QAAQ8J,GAAa,SAAC5R,EAAOoH,EAAK+K,EAAU9P,GAE9D,OADAkR,EAAoBxN,KAAK,CAAEqB,MAAK+K,WAAU9P,UACnC,MAKT,IAAIuF,EAASyL,EAOb,OANAE,EAAoBzO,OAAO0O,SAAS1H,SAAQ,SAAC2H,GAE3C,IAAMpR,EAAQoR,EAAIpR,MAAMmG,OAAO,EAAGiL,EAAIpR,MAAMS,OAAS,GACrD8E,EAAS8L,YAAgB9L,EAAQ6L,EAAIrM,IAAK/E,EAAOoR,EAAItB,aAGhDvK,EAjCE+L,CAAsB/O,EAAOsO,MAGHR,KAAK,IAuCnC,SAAShR,EAAqB+E,GACnC,IAAKA,EACH,OAAOA,EAET,IAAMmN,EAAuC,GAC7C,IAAK,IAAMpN,KAAUC,EAAU,CAC7B,IAAMxB,EAAOwB,EAASD,GAAQ,GACZ,YAAdvB,EAAKyB,OACPkN,EAAgB,GAAD,OAAIpN,EAAJ,WAAsB,CACnC,CACEE,KAAM,UACNC,KAAM,gEAAF,OAAkE1B,EAAK0B,KAAvE,OAGRiN,EAAgB,GAAD,OAAIpN,EAAJ,SAAoB,CACjC,CACEE,KAAM,UACNC,KAAM,yDAAF,OAA2D1B,EAAK0B,KAAhE,QAKZ,O,+VAAA,IAAYF,EAAZ,GAAyBmN,GAGpB,SAASC,EAAaC,GAC3B,OAAOjK,EAAciK,EAAe,KAG/B,SAASjK,EAAckK,GAC5B,OAAOC,KAAKC,MAAMF,EAAU,IAGvB,SAASzN,EAAiBJ,GAC/B,OAAOA,EAAMlE,MAAM,EAAGlC,KAGjB,SAASuG,EAAaH,GAC3B,OAAOA,GAASA,EAAMpD,QAAUhD,IAAzB,iCAAuEA,IAAvE,mBAA4G,K,oCCnNrH,2DAEMoU,EAAW,qDAIXC,EAAe,CACnBD,EAJuB,gBAMvB,yEACA,+BACA,8GACA,gHACA,gHACA,kHAECxB,KAAK,KACLhI,MAAM,KAGH0J,EAA2B,oCAI3BzC,EAAiB,kBAEhB,SAAS+B,EACd9O,EACAwC,EACA/E,EACA8P,EACAkC,GAEA,IAAKjN,IAAQ/E,EACX,MAAM,IAAIqK,MAAM,+BAIlB,IAGI4H,EAHEC,EAAmBlS,IAAU+M,IAAW,OAAS/M,EAAMd,WAK7DqD,EAAQA,EAAMkD,QAAQsM,GAA0B,SAACvQ,EAAO2Q,EAAMhR,GAC5D,IAAMiR,EAsEV,SAAsB7P,EAAe4P,EAAchR,EAAgB8Q,EAAsBD,GACvF,IAAMK,GAPuBtS,EAOgBwC,EAPF+P,EAOSnR,EAPSoR,EAOD,IAPmBC,EAOd,IAN3DC,EAAoB1S,EAAKJ,MAAM2S,GAAUjN,QAAQkN,GACjDG,EAAkB3S,EAAKJ,MAAM2S,GAAUjN,QAAQmN,GAC9CE,GAAmB,KAA6B,IAAvBD,GAA4BA,EAAoBC,IAM1EC,EAAwBV,GAAgBJ,EAASxJ,MAAM,KAAKhD,QAAQ4M,IAAiB,EAErFW,EAAiBT,EAAKU,SAAS,KAE/BC,EAAwC,MAAtBvQ,EAAMpB,EAAS,GAEjC4R,EAA2C,MAAtBxQ,EAAMpB,EAAS,GAEpC6R,EAAa,CAAC,IAAK,IAAK,IAAK,IAAK,KAAKrR,SAASwQ,IAAShB,QAAQ8B,OAAO1Q,EAAMpB,EAAS,KAjB/F,IAA+BpB,EAAcuS,EAAkBC,EAAkBC,EACzEC,EACAC,EAiBN,KACGV,GACAK,GACAO,GACAD,GACAG,GACAC,GACAC,IAC+B,IAAhClB,EAAazM,QAAQ8M,IAErB,OAAO,EAET,OAAO,EA/FYe,CAAa3Q,EAAO4P,EAAMhR,EAAQ8Q,EAAcD,GAGjE,OAFAC,EAAeE,EAERC,EAAW,GAAH,OAAMD,EAAN,MAAiBA,KASlC,IALA,IAAI3Q,EAAQ8N,EAAe6D,KAAK5Q,GAC1B6Q,EAAQ,GACVC,EAAY,EACZnN,EAAS,GAEN1E,GAAO,CACZ,IAAM1B,EAASyC,EAAM5C,MAAM0T,EAAW7R,EAAMuN,OAI5C,GAHAsE,EAAY7R,EAAMuN,MAAQvN,EAAM,GAAGf,OAAS,EAC5CyF,EAAS3D,EAAM5C,MAAM6B,EAAMuN,MAAQvN,EAAM,GAAGf,QAExCe,EAAM,GACR4R,EAAM1P,KAAK5D,GACXsT,EAAM1P,KAAKlC,EAAM,QACZ,CAEL,IACM8R,EAAoBC,EADT/R,EAAM,GACgCuD,EAAKmN,EAAkBpC,GAC9EsD,EAAM1P,KAAK5D,EAAQwT,GAGrB9R,EAAQ8N,EAAe6D,KAAK5Q,GAI9B,OADA6Q,EAAM1P,KAAKwC,GACJkN,EAAM/C,KAAK,IAGpB,IAAMd,EAAc,oCAEb,SAASgE,EAAmB7N,EAAkBzF,EAAkBuT,EAAoBC,GACzF,IAAMC,EAAe,GAGrB,GAAIhO,EAEF,IADA,IAAIlE,EAAQ+N,EAAY4D,KAAKzN,GACtBlE,GACLkS,EAAahQ,KAAK,CAAEqB,IAAKvD,EAAM,GAAIsO,SAAUtO,EAAM,GAAIxB,MAAOwB,EAAM,KACpEA,EAAQ+N,EAAY4D,KAAKzN,GAK7B,IAAMiO,EAAsBF,GAAiB,IAC7CC,EAAahQ,KAAK,CAAEqB,IAAK9E,EAAU6P,SAAU6D,EAAqB3T,MAAO,IAAF,OAAMwT,EAAN,OAGvE,IAAMI,EAAYzR,IAAEC,MAAMsR,GACvBG,SAAS1R,IAAE2R,SACXC,UACAC,OAAO,OACP3R,KAAI,gBAAG0C,EAAH,EAAGA,IAAK+K,EAAR,EAAQA,SAAU9P,EAAlB,EAAkBA,MAAlB,gBAAiC+E,GAAjC,OAAuC+K,GAAvC,OAAkD9P,MACtDA,QACAqQ,KAAK,KAER,iBAAWuD,EAAX,KAqCavC,O,kCC3If,oEAAO,IAAM7I,EAAgC,CAC3C,CAAE7K,MAAO,cAAesW,SAAU,eAClC,CAAEtW,MAAO,mBAAoBsW,SAAU,oBACvC,CAAEtW,MAAO,KAAMsW,SAAU,YACzB,CAAEtW,MAAO,KAAMsW,SAAU,YACzB,CAAEtW,MAAO,MAAOsW,SAAU,YAC1B,CAAEtW,MAAO,MAAOsW,SAAU,YAC1B,CAAEtW,MAAO,KAAMsW,SAAU,YACzB,CAAEtW,MAAO,KAAMsW,SAAU,aA+DdnQ,EAAY,GAAH,OA1D0B,CAC9C,CACEnG,MAAO,MACPuW,WAAY,MACZ1Q,cAAe,iCAEjB,CACE7F,MAAO,MACPuW,WAAY,MACZ1Q,cAAe,kCAEjB,CACE7F,MAAO,MACPuW,WAAY,MACZ1Q,cAAe,kCAEjB,CACE7F,MAAO,MACPuW,WAAY,MACZ1Q,cAAe,yCAEjB,CACE7F,MAAO,SACPuW,WAAY,SACZ1Q,cAAe,2DAEjB,CACE7F,MAAO,SACPuW,WAAY,SACZ1Q,cAAe,0DAEjB,CACE7F,MAAO,QACPuW,WAAY,QACZ1Q,cAAe,0CAEjB,CACE7F,MAAO,eACPuW,WAAY,eACZ1Q,cAAe,gDAEjB,CACE7F,MAAO,UACPuW,WAAY,UACZ1Q,cAAe,uCAEjB,CACE7F,MAAO,OACPuW,WAAY,OACZ1Q,cAAe,sCAEjB,CACE7F,MAAO,WACPuW,WAAY,WACZ1Q,cAAe,qDAIG,CAEpB,CACE0Q,WAAY,MACZvW,MAAO,MACPwW,OAAQ,wBACR3Q,cAAe,sFAEjB,CACE0Q,WAAY,SACZvW,MAAO,SACPwW,OAAQ,2BACR3Q,cACE,mQAEJ,CACE0Q,WAAY,OACZvW,MAAO,OACPwW,OAAQ,yBACR3Q,cAAe,8EAEjB,CACE0Q,WAAY,UACZvW,MAAO,UACPwW,OAAQ,0BACR3Q,cACE,gKAEJ,CACE0Q,WAAY,YACZvW,MAAO,YACPwW,OAAQ,0CACR3Q,cAAe,oFAEjB,CACE0Q,WAAY,YACZvW,MAAO,YACPwW,OAAQ,0CACR3Q,cAAe,mFAEjB,CACE0Q,WAAY,eACZvW,MAAO,eACPwW,OAAQ,iCACR3Q,cACE,6PAEJ,CACE0Q,WAAY,eACZvW,MAAO,eACPwW,OAAQ,gDACR3Q,cAAe,sGAEjB,CACE0Q,WAAY,cACZvW,MAAO,cACPwW,OAAQ,+CACR3Q,cACE,8HAEJ,CACE0Q,WAAY,gBACZvW,MAAO,gBACPwW,OAAQ,iDACR3Q,cACE,8GAEJ,CACE0Q,WAAY,QACZvW,MAAO,QACPwW,OAAQ,wBACR3Q,cACE,2XAEJ,CACE0Q,WAAY,QACZvW,MAAO,QACPwW,OAAQ,wBACR3Q,cACE,kHAEJ,CACE0Q,WAAY,qBACZvW,MAAO,qBACPwW,OAAQ,qCACR3Q,cAAe,6FAEjB,CACE0Q,WAAY,MACZvW,MAAO,MACPwW,OAAQ,wBACR3Q,cACE,+HAEJ,CACE0Q,WAAY,QACZvW,MAAO,QACPwW,OAAQ,0BACR3Q,cAAe,gFAEjB,CACE0Q,WAAY,qBACZvW,MAAO,qBACPwW,OAAQ,gDACR3Q,cACE,kaAEJ,CACE0Q,WAAY,eACZvW,MAAO,eACPwW,OAAQ,qDACR3Q,cACE,gRAEJ,CACE0Q,WAAY,OACZvW,MAAO,OACPwW,OAAQ,wCACR3Q,cAAe,qGAEjB,CACE0Q,WAAY,SACZvW,MAAO,SACPwW,OAAQ,yBACR3Q,cACE,4JAEJ,CACE0Q,WAAY,WACZvW,MAAO,WACPwW,OAAQ,2BACR3Q,cACE,0XAEJ,CACE0Q,WAAY,QACZvW,MAAO,QACPwW,OAAQ,wBACR3Q,cACE,gPAEJ,CACE0Q,WAAY,gBACZvW,MAAO,gBACPwW,OAAQ,wGACR3Q,cACE,qeAEJ,CACE0Q,WAAY,KACZvW,MAAO,KACPwW,OAAQ,uBACR3Q,cACE,oKAEJ,CACE0Q,WAAY,OACZvW,MAAO,OACPwW,OAAQ,yBACR3Q,cACE,+GAEJ,CACE0Q,WAAY,QACZvW,MAAO,QACPwW,OAAQ,0BACR3Q,cACE,gHAEJ,CACE0Q,WAAY,SACZvW,MAAO,SACPwW,OAAQ,0CACR3Q,cACE,wGAEJ,CACE0Q,WAAY,QACZvW,MAAO,QACPwW,OAAQ,yCACR3Q,cACE,kIAEJ,CACE0Q,WAAY,iBACZvW,MAAO,iBACPwW,OAAQ,2CACR3Q,cACE,0HAEJ,CACE0Q,WAAY,OACZvW,MAAO,OACPwW,OAAQ,uBACR3Q,cACE,yWAEJ,CACE0Q,WAAY,SACZvW,MAAO,SACPwW,OAAQ,yBACR3Q,cACE,+OAEJ,CACE0Q,WAAY,QACZvW,MAAO,QACPwW,OAAQ,+CACR3Q,cACE,2QAEJ,CACE0Q,WAAY,SACZvW,MAAO,SACPwW,OAAQ,2BACR3Q,cACE,mNAEJ,CACE0Q,WAAY,OACZvW,MAAO,OACPwW,OAAQ,yBACR3Q,cAAe,8EAEjB,CACE0Q,WAAY,YACZvW,MAAO,YACPwW,OAAQ,8BACR3Q,cAAe,+EAEjB,CACE0Q,WAAY,OACZvW,MAAO,OACPwW,OAAQ,yBACR3Q,cAAe,sDAEjB,CACE0Q,WAAY,OACZvW,MAAO,OACPwW,OAAQ,SACR3Q,cACE,+KAEJ,CACE0Q,WAAY,SACZvW,MAAO,SACPwW,OAAQ,mBACR3Q,cAAe,sDAEjB,CACE0Q,WAAY,OACZvW,MAAO,OACPwW,OAAQ,wCACR3Q,cAAe,wDAEjB,CACE0Q,WAAY,gBACZvW,MAAO,gBACPwW,OAAQ,8BACR3Q,cAAe,8DAEjB,CACE0Q,WAAY,gBACZvW,MAAO,gBACPwW,OAAQ,8BACR3Q,cAAe,8DAEjB,CACE0Q,WAAY,gBACZvW,MAAO,gBACPwW,OAAQ,8BACR3Q,cAAe,8DAEjB,CACE0Q,WAAY,gBACZvW,MAAO,gBACPwW,OAAQ,8BACR3Q,cAAe,oDAEjB,CACE0Q,WAAY,kBACZvW,MAAO,kBACPwW,OAAQ,gCACR3Q,cAAe,sDAEjB,CACE0Q,WAAY,qBACZvW,MAAO,qBACPwW,OAAQ,2CACR3Q,cAAe,uEAEjB,CACE0Q,WAAY,mBACZvW,MAAO,mBACPwW,OAAQ,iCACR3Q,cAAe,8EAEjB,CACE0Q,WAAY,mBACZvW,MAAO,mBACPwW,OAAQ,iCACR3Q,cAAe,+EAIb4Q,EAAqB,CACzBC,QAAS,CACPC,QAAS,OAEX,sBAAuB,CACrBA,QAAS,6BACTC,YAAY,EACZC,OAAQ,CACN,YAAa,CACXF,QAAS,yBACTG,MAAO,aAETC,YAAa,SAGjB,iBAAkB,CAChBJ,QAAS,gBACTK,QAAQ,EACRH,OAAQ,CACNH,QAAS,CACPC,QAAS,OAEX,YAAa,CACXA,QAAS,+BACTG,MAAO,YACPE,QAAQ,GAEV,cAAe,CACbL,QAAS,oBACTK,QAAQ,EACRF,MAAO,cAETC,YAAa,QAGjBE,SAAU,IAAI9F,OAAJ,gBAAoBhL,EAAUzB,KAAI,SAACwS,GAAD,OAAOA,EAAElX,SAAO0S,KAAK,KAAvD,gBAA2E,KACrF,gBAAiB,CACf,CACEiE,QAAS,gBACTE,OAAQ,CACN,iBAAkB,CAChBF,QAAS,mBACTG,MAAO,YAIb,CACEH,QAAS,iBACTC,YAAY,EACZC,OAAQ,CACN,iBAAkB,CAChBF,QAAS,mBACTG,MAAO,aAKfK,OAAQ,sCACRhF,SAAU,IAAIhB,OAAJ,iEAvaa,CAAC,KAAM,aAAc,cAAe,WAAY,KAAM,SAAU,WAuaEuB,KAAK,KAApF,QAAgG,KAC1GqE,YAAa,cAGAN","file":"default~lokiPlugin~prometheusPlugin.1c3a1c85d09a392be724.js","sourcesContent":["import _ from 'lodash';\nimport LRU from 'lru-cache';\nimport { Value } from 'slate';\n\nimport { dateTime, HistoryItem, LanguageProvider } from '@grafana/data';\nimport { CompletionItem, CompletionItemGroup, TypeaheadInput, TypeaheadOutput } from '@grafana/ui';\n\nimport {\n  fixSummariesMetadata,\n  parseSelector,\n  processHistogramLabels,\n  processLabels,\n  roundSecToMin,\n  addLimitInfo,\n  limitSuggestions,\n} from './language_utils';\nimport PromqlSyntax, { FUNCTIONS, RATE_RANGES } from './promql';\n\nimport { PrometheusDatasource } from './datasource';\nimport { PromMetricsMetadata, PromQuery } from './types';\n\nconst DEFAULT_KEYS = ['job', 'instance'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 5;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\n// Max number of items (metrics, labels, values) that we display as suggestions. Prevents from running out of memory.\nexport const SUGGESTIONS_LIMIT = 10000;\n\nconst wrapLabel = (label: string): CompletionItem => ({ label });\n\nconst setFunctionKind = (suggestion: CompletionItem): CompletionItem => {\n  suggestion.kind = 'function';\n  return suggestion;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: any[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter((h) => h.ts > cutoffTs && h.query === item.label);\n  const count = historyForItem.length;\n  const recent = historyForItem[0];\n  let hint = `Queried ${count} times in the last 24h.`;\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CompletionItem {\n  const item: CompletionItem = { label: metric };\n  if (metadata && metadata[metric]) {\n    const { type, help } = metadata[metric][0];\n    item.documentation = `${type.toUpperCase()}: ${help}`;\n  }\n  return item;\n}\n\nconst PREFIX_DELIMITER_REGEX = /(=\"|!=\"|=~\"|!~\"|\\{|\\[|\\(|\\+|-|\\/|\\*|%|\\^|\\band\\b|\\bor\\b|\\bunless\\b|==|>=|!=|<=|>|<|=|~|,)/;\n\nexport default class PromQlLanguageProvider extends LanguageProvider {\n  histogramMetrics: string[];\n  timeRange?: { start: number; end: number };\n  metrics: string[];\n  metricsMetadata?: PromMetricsMetadata;\n  startTask: Promise<any>;\n  datasource: PrometheusDatasource;\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private labelsCache = new LRU<string, Record<string, string[]>>(10);\n\n  constructor(datasource: PrometheusDatasource, initialValues?: Partial<PromQlLanguageProvider>) {\n    super();\n\n    this.datasource = datasource;\n    this.histogramMetrics = [];\n    this.timeRange = { start: 0, end: 0 };\n    this.metrics = [];\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars so that typeahead suggestions can work on clean inputs\n  cleanText(s: string) {\n    const parts = s.split(PREFIX_DELIMITER_REGEX);\n    const last = parts.pop()!;\n    return last.trimLeft().replace(/\"$/, '').replace(/^\"/, '');\n  }\n\n  get syntax() {\n    return PromqlSyntax;\n  }\n\n  request = async (url: string, defaultValue: any, params = {}): Promise<any> => {\n    try {\n      const res = await this.datasource.metadataRequest(url, params);\n      return res.data.data;\n    } catch (error) {\n      console.error(error);\n    }\n\n    return defaultValue;\n  };\n\n  start = async (): Promise<any[]> => {\n    if (this.datasource.lookupsDisabled) {\n      return [];\n    }\n\n    const tRange = this.datasource.getTimeRange();\n    const params = {\n      start: tRange['start'].toString(),\n      end: tRange['end'].toString(),\n    };\n    const url = `/api/v1/label/__name__/values`;\n\n    this.metrics = await this.request(url, [], params);\n    this.metricsMetadata = fixSummariesMetadata(await this.request('/api/v1/metadata', {}));\n    this.processHistogramMetrics(this.metrics);\n\n    return [];\n  };\n\n  processHistogramMetrics = (data: string[]) => {\n    const { values } = processHistogramLabels(data);\n\n    if (values && values['__name__']) {\n      this.histogramMetrics = values['__name__'].slice().sort();\n    }\n  };\n\n  provideCompletionItems = async (\n    { prefix, text, value, labelKey, wrapperClasses }: TypeaheadInput,\n    context: { history: Array<HistoryItem<PromQuery>> } = { history: [] }\n  ): Promise<TypeaheadOutput> => {\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^[\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}\n      return this.getLabelCompletionItems({ prefix, text, value, labelKey, wrapperClasses });\n    } else if (wrapperClasses.includes('context-aggregation')) {\n      // Suggestions for sum(metric) by (|)\n      return this.getAggregationCompletionItems(value);\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  };\n\n  getBeginningCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\n    const { history } = context;\n    const suggestions = [];\n\n    if (history && history.length) {\n      const historyItems = _.chain(history)\n        .map((h) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const { metrics, metricsMetadata } = this;\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map(setFunctionKind),\n    });\n\n    if (metrics && metrics.length) {\n      const limitInfo = addLimitInfo(metrics);\n      suggestions.push({\n        label: `Metrics${limitInfo}`,\n        items: limitSuggestions(metrics).map((m) => addMetricsMetadata(m, metricsMetadata)),\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  getAggregationCompletionItems = async (value: Value): Promise<TypeaheadOutput> => {\n    const suggestions: CompletionItemGroup[] = [];\n\n    // Stitch all query lines together to support multi-line queries\n    let queryOffset;\n    const queryText = value.document.getBlocks().reduce((text: string, block) => {\n      if (!block) {\n        return text;\n      }\n\n      const blockText = block?.getText();\n\n      if (value.anchorBlock.key === block.key) {\n        // Newline characters are not accounted for but this is irrelevant\n        // for the purpose of extracting the selector string\n        queryOffset = value.selection.anchor.offset + text.length;\n      }\n\n      return text + blockText;\n    }, '');\n\n    // Try search for selector part on the left-hand side, such as `sum (m) by (l)`\n    const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);\n    let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);\n    let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex);\n\n    // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`\n    if (openParensSelectorIndex === -1) {\n      const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);\n      closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);\n      openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);\n    }\n\n    const result = {\n      suggestions,\n      context: 'context-aggregation',\n    };\n\n    // Suggestions are useless for alternative aggregation clauses without a selector in context\n    if (openParensSelectorIndex === -1) {\n      return result;\n    }\n\n    // Range vector syntax not accounted for by subsequent parse so discard it if present\n    const selectorString = queryText\n      .slice(openParensSelectorIndex + 1, closeParensSelectorIndex)\n      .replace(/\\[[^\\]]+\\]$/, '');\n\n    const selector = parseSelector(selectorString, selectorString.length - 2).selector;\n\n    const labelValues = await this.getLabelValues(selector);\n    if (labelValues) {\n      const limitInfo = addLimitInfo(labelValues[0]);\n      suggestions.push({\n        label: `Labels${limitInfo}`,\n        items: Object.keys(labelValues).map(wrapLabel),\n      });\n    }\n    return result;\n  };\n\n  getLabelCompletionItems = async ({\n    text,\n    wrapperClasses,\n    labelKey,\n    value,\n  }: TypeaheadInput): Promise<TypeaheadOutput> => {\n    if (!value) {\n      return { suggestions: [] };\n    }\n\n    const suggestions: CompletionItemGroup[] = [];\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const suffix = line.substr(cursorOffset);\n    const prefix = line.substr(0, cursorOffset);\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n    const isValueEnd = suffix.match(/^\"?[,}]|$/);\n    // Detect cursor in front of value, e.g., {key=|\"}\n    const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^\"/);\n\n    // Don't suggest anything at the beginning or inside a value\n    const isValueEmpty = isValueStart && isValueEnd;\n    const hasValuePrefix = isValueEnd && !isValueStart;\n    if ((!isValueEmpty && !hasValuePrefix) || isPreValue) {\n      return { suggestions };\n    }\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    const containsMetric = selector.includes('__name__=');\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      labelValues = await this.getLabelValues(selector, !containsMetric);\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { suggestions };\n    }\n\n    let context: string | undefined;\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        const limitInfo = addLimitInfo(labelValues[labelKey]);\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"${limitInfo}`,\n          items: labelValues[labelKey].map(wrapLabel),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : containsMetric ? null : DEFAULT_KEYS;\n\n      if (labelKeys) {\n        const possibleKeys = _.difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          context = 'context-labels';\n          const newItems = possibleKeys.map((key) => ({ label: key }));\n          const limitInfo = addLimitInfo(newItems);\n          const newSuggestion: CompletionItemGroup = { label: `Labels${limitInfo}`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  };\n\n  async getLabelValues(selector: string, withName?: boolean) {\n    if (this.datasource.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      if (selector === EMPTY_SELECTOR) {\n        return await this.fetchDefaultLabels();\n      } else {\n        return await this.fetchSeriesLabels(selector, withName);\n      }\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  fetchLabelValues = async (key: string): Promise<Record<string, string[]>> => {\n    const tRange = this.datasource.getTimeRange();\n    const params = {\n      start: tRange['start'].toString(),\n      end: tRange['end'].toString(),\n    };\n    const url = `/api/v1/label/${key}/values`;\n    const data = await this.request(url, [], params);\n    return { [key]: data };\n  };\n\n  /**\n   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   * @param withName\n   */\n  fetchSeriesLabels = async (name: string, withName?: boolean): Promise<Record<string, string[]>> => {\n    const tRange = this.datasource.getTimeRange();\n    const urlParams = {\n      'match[]': name,\n      start: tRange['start'].toString(),\n      end: tRange['end'].toString(),\n    };\n    const url = `/api/v1/series`;\n    // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.\n    // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n    // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n    // when user does not the newest values for a minute if already cached.\n    const cacheParams = new URLSearchParams({\n      'match[]': name,\n      start: roundSecToMin(tRange['start']).toString(),\n      end: roundSecToMin(tRange['end']).toString(),\n      withName: withName ? 'true' : 'false',\n    });\n\n    const cacheKey = `/api/v1/series?${cacheParams.toString()}`;\n    let value = this.labelsCache.get(cacheKey);\n    if (!value) {\n      const data = await this.request(url, [], urlParams);\n      const { values } = processLabels(data, withName);\n      value = values;\n      this.labelsCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch this only one as we assume this won't change over time. This is cached differently from fetchSeriesLabels\n   * because we can cache more aggressively here and also we do not want to invalidate this cache the same way as in\n   * fetchSeriesLabels.\n   */\n  fetchDefaultLabels = _.once(async () => {\n    const values = await Promise.all(DEFAULT_KEYS.map((key) => this.fetchLabelValues(key)));\n    return values.reduce((acc, value) => ({ ...acc, ...value }), {});\n  });\n}\n","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount /*, ...nodes */) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 2; i < arguments.length; i++) {\n    walker = insert(this, walker, arguments[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","'use strict'\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = require('yallist')\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n","import { PromMetricsMetadata } from './types';\nimport { addLabelToQuery } from './add_label_to_query';\nimport { SUGGESTIONS_LIMIT } from './language_provider';\n\nexport const RATE_RANGES = ['1m', '5m', '10m', '30m', '1h'];\n\nexport const processHistogramLabels = (labels: string[]) => {\n  const resultSet: Set<string> = new Set();\n  const regexp = new RegExp('_bucket($|:)');\n  for (let index = 0; index < labels.length; index++) {\n    const label = labels[index];\n    const isHistogramValue = regexp.test(label);\n    if (isHistogramValue) {\n      resultSet.add(label);\n    }\n  }\n  const result = [...resultSet];\n\n  return { values: { __name__: result } };\n};\n\nexport function processLabels(labels: Array<{ [key: string]: string }>, withName = false) {\n  // For processing we are going to use sets as they have significantly better performance than arrays\n  // After we process labels, we will convert sets to arrays and return object with label values in arrays\n  const valueSet: { [key: string]: Set<string> } = {};\n  labels.forEach((label) => {\n    const { __name__, ...rest } = label;\n    if (withName) {\n      valueSet['__name__'] = valueSet['__name__'] || new Set();\n      if (!valueSet['__name__'].has(__name__)) {\n        valueSet['__name__'].add(__name__);\n      }\n    }\n\n    Object.keys(rest).forEach((key) => {\n      if (!valueSet[key]) {\n        valueSet[key] = new Set();\n      }\n      if (!valueSet[key].has(rest[key])) {\n        valueSet[key].add(rest[key]);\n      }\n    });\n  });\n\n  // valueArray that we are going to return in the object\n  const valueArray: { [key: string]: string[] } = {};\n  limitSuggestions(Object.keys(valueSet)).forEach((key) => {\n    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));\n  });\n\n  return { values: valueArray, keys: Object.keys(valueArray) };\n}\n\n// const cleanSelectorRegexp = /\\{(\\w+=\"[^\"\\n]*?\")(,\\w+=\"[^\"\\n]*?\")*\\}/;\nexport const selectorRegexp = /\\{[^}]*?(\\}|$)/;\nexport const labelRegexp = /\\b(\\w+)(!?=~?)(\"[^\"\\n]*?\")/g;\nexport function parseSelector(query: string, cursorOffset = 1): { labelKeys: any[]; selector: string } {\n  if (!query.match(selectorRegexp)) {\n    // Special matcher for metrics\n    if (query.match(/^[A-Za-z:][\\w:]*$/)) {\n      return {\n        selector: `{__name__=\"${query}\"}`,\n        labelKeys: ['__name__'],\n      };\n    }\n    throw new Error('Query must contain a selector: ' + query);\n  }\n\n  // Check if inside a selector\n  const prefix = query.slice(0, cursorOffset);\n  const prefixOpen = prefix.lastIndexOf('{');\n  const prefixClose = prefix.lastIndexOf('}');\n  if (prefixOpen === -1) {\n    throw new Error('Not inside selector, missing open brace: ' + prefix);\n  }\n  if (prefixClose > -1 && prefixClose > prefixOpen) {\n    throw new Error('Not inside selector, previous selector already closed: ' + prefix);\n  }\n  const suffix = query.slice(cursorOffset);\n  const suffixCloseIndex = suffix.indexOf('}');\n  const suffixClose = suffixCloseIndex + cursorOffset;\n  const suffixOpenIndex = suffix.indexOf('{');\n  const suffixOpen = suffixOpenIndex + cursorOffset;\n  if (suffixClose === -1) {\n    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);\n  }\n  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {\n    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);\n  }\n\n  // Extract clean labels to form clean selector, incomplete labels are dropped\n  const selector = query.slice(prefixOpen, suffixClose);\n  const labels: { [key: string]: { value: string; operator: string } } = {};\n  selector.replace(labelRegexp, (label, key, operator, value) => {\n    const labelOffset = query.indexOf(label);\n    const valueStart = labelOffset + key.length + operator.length + 1;\n    const valueEnd = labelOffset + key.length + operator.length + value.length - 1;\n    // Skip label if cursor is in value\n    if (cursorOffset < valueStart || cursorOffset > valueEnd) {\n      labels[key] = { value, operator };\n    }\n    return '';\n  });\n\n  // Add metric if there is one before the selector\n  const metricPrefix = query.slice(0, prefixOpen);\n  const metricMatch = metricPrefix.match(/[A-Za-z:][\\w:]*$/);\n  if (metricMatch) {\n    labels['__name__'] = { value: `\"${metricMatch[0]}\"`, operator: '=' };\n  }\n\n  // Build sorted selector\n  const labelKeys = Object.keys(labels).sort();\n  const cleanSelector = labelKeys.map((key) => `${key}${labels[key].operator}${labels[key].value}`).join(',');\n\n  const selectorString = ['{', cleanSelector, '}'].join('');\n\n  return { labelKeys, selector: selectorString };\n}\n\nexport function expandRecordingRules(query: string, mapping: { [name: string]: string }): string {\n  const ruleNames = Object.keys(mapping);\n  const rulesRegex = new RegExp(`(\\\\s|^)(${ruleNames.join('|')})(\\\\s|$|\\\\(|\\\\[|\\\\{)`, 'ig');\n  const expandedQuery = query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`);\n\n  // Split query into array, so if query uses operators, we can correctly add labels to each individual part.\n  const queryArray = expandedQuery.split(/(\\+|\\-|\\*|\\/|\\%|\\^)/);\n\n  // Regex that matches occurrences of ){ or }{ or ]{ which is a sign of incorrecly added labels.\n  const invalidLabelsRegex = /(\\)\\{|\\}\\{|\\]\\{)/;\n  const correctlyExpandedQueryArray = queryArray.map((query) => {\n    return addLabelsToExpression(query, invalidLabelsRegex);\n  });\n\n  return correctlyExpandedQueryArray.join('');\n}\n\nfunction addLabelsToExpression(expr: string, invalidLabelsRegexp: RegExp) {\n  const match = expr.match(invalidLabelsRegexp);\n  if (!match) {\n    return expr;\n  }\n\n  // Split query into 2 parts - before the invalidLabelsRegex match and after.\n  const indexOfRegexMatch = match.index ?? 0;\n  const exprBeforeRegexMatch = expr.substr(0, indexOfRegexMatch + 1);\n  const exprAfterRegexMatch = expr.substr(indexOfRegexMatch + 1);\n\n  // Create arrayOfLabelObjects with label objects that have key, operator and value.\n  const arrayOfLabelObjects: Array<{ key: string; operator: string; value: string }> = [];\n  exprAfterRegexMatch.replace(labelRegexp, (label, key, operator, value) => {\n    arrayOfLabelObjects.push({ key, operator, value });\n    return '';\n  });\n\n  // Loop trough all of the label objects and add them to query.\n  // As a starting point we have valid query without the labels.\n  let result = exprBeforeRegexMatch;\n  arrayOfLabelObjects.filter(Boolean).forEach((obj) => {\n    // Remove extra set of quotes from obj.value\n    const value = obj.value.substr(1, obj.value.length - 2);\n    result = addLabelToQuery(result, obj.key, value, obj.operator);\n  });\n\n  return result;\n}\n\n/**\n * Adds metadata for synthetic metrics for which the API does not provide metadata.\n * See https://github.com/grafana/grafana/issues/22337 for details.\n *\n * @param metadata HELP and TYPE metadata from /api/v1/metadata\n */\nexport function fixSummariesMetadata(metadata: PromMetricsMetadata): PromMetricsMetadata {\n  if (!metadata) {\n    return metadata;\n  }\n  const summaryMetadata: PromMetricsMetadata = {};\n  for (const metric in metadata) {\n    const item = metadata[metric][0];\n    if (item.type === 'summary') {\n      summaryMetadata[`${metric}_count`] = [\n        {\n          type: 'counter',\n          help: `Count of events that have been observed for the base metric (${item.help})`,\n        },\n      ];\n      summaryMetadata[`${metric}_sum`] = [\n        {\n          type: 'counter',\n          help: `Total sum of all observed values for the base metric (${item.help})`,\n        },\n      ];\n    }\n  }\n  return { ...metadata, ...summaryMetadata };\n}\n\nexport function roundMsToMin(milliseconds: number): number {\n  return roundSecToMin(milliseconds / 1000);\n}\n\nexport function roundSecToMin(seconds: number): number {\n  return Math.floor(seconds / 60);\n}\n\nexport function limitSuggestions(items: string[]) {\n  return items.slice(0, SUGGESTIONS_LIMIT);\n}\n\nexport function addLimitInfo(items: any[] | undefined): string {\n  return items && items.length >= SUGGESTIONS_LIMIT ? `, limited to the first ${SUGGESTIONS_LIMIT} received items` : '';\n}\n","import _ from 'lodash';\n\nconst keywords = 'by|without|on|ignoring|group_left|group_right|bool';\nconst logicalOperators = 'or|and|unless';\n\n// Duplicate from mode-prometheus.js, which can't be used in tests due to global ace not being loaded.\nconst builtInWords = [\n  keywords,\n  logicalOperators,\n  'count|count_values|min|max|avg|sum|stddev|stdvar|bottomk|topk|quantile',\n  'true|false|null|__name__|job',\n  'abs|absent|ceil|changes|clamp_max|clamp_min|count_scalar|day_of_month|day_of_week|days_in_month|delta|deriv',\n  'drop_common_labels|exp|floor|histogram_quantile|holt_winters|hour|idelta|increase|irate|label_replace|ln|log2',\n  'log10|minute|month|predict_linear|rate|resets|round|scalar|sort|sort_desc|sqrt|time|vector|year|avg_over_time',\n  'min_over_time|max_over_time|sum_over_time|count_over_time|quantile_over_time|stddev_over_time|stdvar_over_time',\n]\n  .join('|')\n  .split('|');\n\n// We want to extract all possible metrics and also keywords\nconst metricsAndKeywordsRegexp = /([A-Za-z:][\\w:]*)\\b(?![\\]{=!\",])/g;\n// Safari currently doesn't support negative lookbehind. When it does, we should refactor this.\n// We are creating 2 matching groups. (\\$) is for the Grafana's variables such as ${__rate_s}. We want to ignore\n// ${__rate_s} and not add variable to it.\nconst selectorRegexp = /(\\$)?{([^{]*)}/g;\n\nexport function addLabelToQuery(\n  query: string,\n  key: string,\n  value: string | number,\n  operator?: string,\n  hasNoMetrics?: boolean\n): string {\n  if (!key || !value) {\n    throw new Error('Need label to add to query.');\n  }\n\n  // We need to make sure that we convert the value back to string because it may be a number\n  const transformedValue = value === Infinity ? '+Inf' : value.toString();\n\n  // Add empty selectors to bare metric names\n  let previousWord: string;\n\n  query = query.replace(metricsAndKeywordsRegexp, (match, word, offset) => {\n    const isMetric = isWordMetric(query, word, offset, previousWord, hasNoMetrics);\n    previousWord = word;\n\n    return isMetric ? `${word}{}` : word;\n  });\n\n  // Adding label to existing selectors\n  let match = selectorRegexp.exec(query);\n  const parts = [];\n  let lastIndex = 0;\n  let suffix = '';\n\n  while (match) {\n    const prefix = query.slice(lastIndex, match.index);\n    lastIndex = match.index + match[2].length + 2;\n    suffix = query.slice(match.index + match[0].length);\n    // If we matched 1st group, we know it is Grafana's variable and we don't want to add labels\n    if (match[1]) {\n      parts.push(prefix);\n      parts.push(match[0]);\n    } else {\n      // If we didn't match first group, we are inside selector and we want to add labels\n      const selector = match[2];\n      const selectorWithLabel = addLabelToSelector(selector, key, transformedValue, operator);\n      parts.push(prefix, selectorWithLabel);\n    }\n\n    match = selectorRegexp.exec(query);\n  }\n\n  parts.push(suffix);\n  return parts.join('');\n}\n\nconst labelRegexp = /(\\w+)\\s*(=|!=|=~|!~)\\s*(\"[^\"]*\")/g;\n\nexport function addLabelToSelector(selector: string, labelKey: string, labelValue: string, labelOperator?: string) {\n  const parsedLabels = [];\n\n  // Split selector into labels\n  if (selector) {\n    let match = labelRegexp.exec(selector);\n    while (match) {\n      parsedLabels.push({ key: match[1], operator: match[2], value: match[3] });\n      match = labelRegexp.exec(selector);\n    }\n  }\n\n  // Add new label\n  const operatorForLabelKey = labelOperator || '=';\n  parsedLabels.push({ key: labelKey, operator: operatorForLabelKey, value: `\"${labelValue}\"` });\n\n  // Sort labels by key and put them together\n  const formatted = _.chain(parsedLabels)\n    .uniqWith(_.isEqual)\n    .compact()\n    .sortBy('key')\n    .map(({ key, operator, value }) => `${key}${operator}${value}`)\n    .value()\n    .join(',');\n\n  return `{${formatted}}`;\n}\n\nfunction isPositionInsideChars(text: string, position: number, openChar: string, closeChar: string) {\n  const nextSelectorStart = text.slice(position).indexOf(openChar);\n  const nextSelectorEnd = text.slice(position).indexOf(closeChar);\n  return nextSelectorEnd > -1 && (nextSelectorStart === -1 || nextSelectorStart > nextSelectorEnd);\n}\n\nfunction isWordMetric(query: string, word: string, offset: number, previousWord: string, hasNoMetrics?: boolean) {\n  const insideSelector = isPositionInsideChars(query, offset, '{', '}');\n  // Handle \"sum by (key) (metric)\"\n  const previousWordIsKeyWord = previousWord && keywords.split('|').indexOf(previousWord) > -1;\n  // Check for colon as as \"word boundary\" symbol\n  const isColonBounded = word.endsWith(':');\n  // Check for words that start with \" which means that they are not metrics\n  const startsWithQuote = query[offset - 1] === '\"';\n  // Check for template variables\n  const isTemplateVariable = query[offset - 1] === '$';\n  // Check for time units\n  const isTimeUnit = ['s', 'm', 'h', 'd', 'w'].includes(word) && Boolean(Number(query[offset - 1]));\n\n  if (\n    !hasNoMetrics &&\n    !insideSelector &&\n    !isColonBounded &&\n    !previousWordIsKeyWord &&\n    !startsWithQuote &&\n    !isTemplateVariable &&\n    !isTimeUnit &&\n    builtInWords.indexOf(word) === -1\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport default addLabelToQuery;\n","import { Grammar } from 'prismjs';\nimport { CompletionItem } from '@grafana/ui';\n\nexport const RATE_RANGES: CompletionItem[] = [\n  { label: '$__interval', sortText: '$__interval' },\n  { label: '$__rate_interval', sortText: '$__rate_interval' },\n  { label: '1m', sortText: '00:01:00' },\n  { label: '5m', sortText: '00:05:00' },\n  { label: '10m', sortText: '00:10:00' },\n  { label: '30m', sortText: '00:30:00' },\n  { label: '1h', sortText: '01:00:00' },\n  { label: '1d', sortText: '24:00:00' },\n];\n\nexport const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];\n\nconst AGGREGATION_OPERATORS: CompletionItem[] = [\n  {\n    label: 'sum',\n    insertText: 'sum',\n    documentation: 'Calculate sum over dimensions',\n  },\n  {\n    label: 'min',\n    insertText: 'min',\n    documentation: 'Select minimum over dimensions',\n  },\n  {\n    label: 'max',\n    insertText: 'max',\n    documentation: 'Select maximum over dimensions',\n  },\n  {\n    label: 'avg',\n    insertText: 'avg',\n    documentation: 'Calculate the average over dimensions',\n  },\n  {\n    label: 'stddev',\n    insertText: 'stddev',\n    documentation: 'Calculate population standard deviation over dimensions',\n  },\n  {\n    label: 'stdvar',\n    insertText: 'stdvar',\n    documentation: 'Calculate population standard variance over dimensions',\n  },\n  {\n    label: 'count',\n    insertText: 'count',\n    documentation: 'Count number of elements in the vector',\n  },\n  {\n    label: 'count_values',\n    insertText: 'count_values',\n    documentation: 'Count number of elements with the same value',\n  },\n  {\n    label: 'bottomk',\n    insertText: 'bottomk',\n    documentation: 'Smallest k elements by sample value',\n  },\n  {\n    label: 'topk',\n    insertText: 'topk',\n    documentation: 'Largest k elements by sample value',\n  },\n  {\n    label: 'quantile',\n    insertText: 'quantile',\n    documentation: 'Calculate -quantile (0    1) over dimensions',\n  },\n];\n\nexport const FUNCTIONS = [\n  ...AGGREGATION_OPERATORS,\n  {\n    insertText: 'abs',\n    label: 'abs',\n    detail: 'abs(v instant-vector)',\n    documentation: 'Returns the input vector with all sample values converted to their absolute value.',\n  },\n  {\n    insertText: 'absent',\n    label: 'absent',\n    detail: 'absent(v instant-vector)',\n    documentation:\n      'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.',\n  },\n  {\n    insertText: 'ceil',\n    label: 'ceil',\n    detail: 'ceil(v instant-vector)',\n    documentation: 'Rounds the sample values of all elements in `v` up to the nearest integer.',\n  },\n  {\n    insertText: 'changes',\n    label: 'changes',\n    detail: 'changes(v range-vector)',\n    documentation:\n      'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.',\n  },\n  {\n    insertText: 'clamp_max',\n    label: 'clamp_max',\n    detail: 'clamp_max(v instant-vector, max scalar)',\n    documentation: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.',\n  },\n  {\n    insertText: 'clamp_min',\n    label: 'clamp_min',\n    detail: 'clamp_min(v instant-vector, min scalar)',\n    documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.',\n  },\n  {\n    insertText: 'count_scalar',\n    label: 'count_scalar',\n    detail: 'count_scalar(v instant-vector)',\n    documentation:\n      'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.',\n  },\n  {\n    insertText: 'day_of_month',\n    label: 'day_of_month',\n    detail: 'day_of_month(v=vector(time()) instant-vector)',\n    documentation: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.',\n  },\n  {\n    insertText: 'day_of_week',\n    label: 'day_of_week',\n    detail: 'day_of_week(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.',\n  },\n  {\n    insertText: 'days_in_month',\n    label: 'days_in_month',\n    detail: 'days_in_month(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.',\n  },\n  {\n    insertText: 'delta',\n    label: 'delta',\n    detail: 'delta(v range-vector)',\n    documentation:\n      'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.',\n  },\n  {\n    insertText: 'deriv',\n    label: 'deriv',\n    detail: 'deriv(v range-vector)',\n    documentation:\n      'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.',\n  },\n  {\n    insertText: 'drop_common_labels',\n    label: 'drop_common_labels',\n    detail: 'drop_common_labels(instant-vector)',\n    documentation: 'Drops all labels that have the same name and value across all series in the input vector.',\n  },\n  {\n    insertText: 'exp',\n    label: 'exp',\n    detail: 'exp(v instant-vector)',\n    documentation:\n      'Calculates the exponential function for all elements in `v`.\\nSpecial cases are:\\n* `Exp(+Inf) = +Inf` \\n* `Exp(NaN) = NaN`',\n  },\n  {\n    insertText: 'floor',\n    label: 'floor',\n    detail: 'floor(v instant-vector)',\n    documentation: 'Rounds the sample values of all elements in `v` down to the nearest integer.',\n  },\n  {\n    insertText: 'histogram_quantile',\n    label: 'histogram_quantile',\n    detail: 'histogram_quantile( float, b instant-vector)',\n    documentation:\n      'Calculates the -quantile (0    1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.',\n  },\n  {\n    insertText: 'holt_winters',\n    label: 'holt_winters',\n    detail: 'holt_winters(v range-vector, sf scalar, tf scalar)',\n    documentation:\n      'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.',\n  },\n  {\n    insertText: 'hour',\n    label: 'hour',\n    detail: 'hour(v=vector(time()) instant-vector)',\n    documentation: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.',\n  },\n  {\n    insertText: 'idelta',\n    label: 'idelta',\n    detail: 'idelta(v range-vector)',\n    documentation:\n      'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.',\n  },\n  {\n    insertText: 'increase',\n    label: 'increase',\n    detail: 'increase(v range-vector)',\n    documentation:\n      'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.',\n  },\n  {\n    insertText: 'irate',\n    label: 'irate',\n    detail: 'irate(v range-vector)',\n    documentation:\n      'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.',\n  },\n  {\n    insertText: 'label_replace',\n    label: 'label_replace',\n    detail: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',\n    documentation:\n      \"For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn't match then the timeseries is returned unchanged.\",\n  },\n  {\n    insertText: 'ln',\n    label: 'ln',\n    detail: 'ln(v instant-vector)',\n    documentation:\n      'calculates the natural logarithm for all elements in `v`.\\nSpecial cases are:\\n * `ln(+Inf) = +Inf`\\n * `ln(0) = -Inf`\\n * `ln(x < 0) = NaN`\\n * `ln(NaN) = NaN`',\n  },\n  {\n    insertText: 'log2',\n    label: 'log2',\n    detail: 'log2(v instant-vector)',\n    documentation:\n      'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.',\n  },\n  {\n    insertText: 'log10',\n    label: 'log10',\n    detail: 'log10(v instant-vector)',\n    documentation:\n      'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.',\n  },\n  {\n    insertText: 'minute',\n    label: 'minute',\n    detail: 'minute(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.',\n  },\n  {\n    insertText: 'month',\n    label: 'month',\n    detail: 'month(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.',\n  },\n  {\n    insertText: 'predict_linear',\n    label: 'predict_linear',\n    detail: 'predict_linear(v range-vector, t scalar)',\n    documentation:\n      'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.',\n  },\n  {\n    insertText: 'rate',\n    label: 'rate',\n    detail: 'rate(v range-vector)',\n    documentation:\n      \"Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period.\",\n  },\n  {\n    insertText: 'resets',\n    label: 'resets',\n    detail: 'resets(v range-vector)',\n    documentation:\n      'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.',\n  },\n  {\n    insertText: 'round',\n    label: 'round',\n    detail: 'round(v instant-vector, to_nearest=1 scalar)',\n    documentation:\n      'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.',\n  },\n  {\n    insertText: 'scalar',\n    label: 'scalar',\n    detail: 'scalar(v instant-vector)',\n    documentation:\n      'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.',\n  },\n  {\n    insertText: 'sort',\n    label: 'sort',\n    detail: 'sort(v instant-vector)',\n    documentation: 'Returns vector elements sorted by their sample values, in ascending order.',\n  },\n  {\n    insertText: 'sort_desc',\n    label: 'sort_desc',\n    detail: 'sort_desc(v instant-vector)',\n    documentation: 'Returns vector elements sorted by their sample values, in descending order.',\n  },\n  {\n    insertText: 'sqrt',\n    label: 'sqrt',\n    detail: 'sqrt(v instant-vector)',\n    documentation: 'Calculates the square root of all elements in `v`.',\n  },\n  {\n    insertText: 'time',\n    label: 'time',\n    detail: 'time()',\n    documentation:\n      'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.',\n  },\n  {\n    insertText: 'vector',\n    label: 'vector',\n    detail: 'vector(s scalar)',\n    documentation: 'Returns the scalar `s` as a vector with no labels.',\n  },\n  {\n    insertText: 'year',\n    label: 'year',\n    detail: 'year(v=vector(time()) instant-vector)',\n    documentation: 'Returns the year for each of the given times in UTC.',\n  },\n  {\n    insertText: 'avg_over_time',\n    label: 'avg_over_time',\n    detail: 'avg_over_time(range-vector)',\n    documentation: 'The average value of all points in the specified interval.',\n  },\n  {\n    insertText: 'min_over_time',\n    label: 'min_over_time',\n    detail: 'min_over_time(range-vector)',\n    documentation: 'The minimum value of all points in the specified interval.',\n  },\n  {\n    insertText: 'max_over_time',\n    label: 'max_over_time',\n    detail: 'max_over_time(range-vector)',\n    documentation: 'The maximum value of all points in the specified interval.',\n  },\n  {\n    insertText: 'sum_over_time',\n    label: 'sum_over_time',\n    detail: 'sum_over_time(range-vector)',\n    documentation: 'The sum of all values in the specified interval.',\n  },\n  {\n    insertText: 'count_over_time',\n    label: 'count_over_time',\n    detail: 'count_over_time(range-vector)',\n    documentation: 'The count of all values in the specified interval.',\n  },\n  {\n    insertText: 'quantile_over_time',\n    label: 'quantile_over_time',\n    detail: 'quantile_over_time(scalar, range-vector)',\n    documentation: 'The -quantile (0    1) of the values in the specified interval.',\n  },\n  {\n    insertText: 'stddev_over_time',\n    label: 'stddev_over_time',\n    detail: 'stddev_over_time(range-vector)',\n    documentation: 'The population standard deviation of the values in the specified interval.',\n  },\n  {\n    insertText: 'stdvar_over_time',\n    label: 'stdvar_over_time',\n    detail: 'stdvar_over_time(range-vector)',\n    documentation: 'The population standard variance of the values in the specified interval.',\n  },\n];\n\nconst tokenizer: Grammar = {\n  comment: {\n    pattern: /#.*/,\n  },\n  'context-aggregation': {\n    pattern: /((by|without)\\s*)\\([^)]*\\)/, // by ()\n    lookbehind: true,\n    inside: {\n      'label-key': {\n        pattern: /[^(),\\s][^,)]*[^),\\s]*/,\n        alias: 'attr-name',\n      },\n      punctuation: /[()]/,\n    },\n  },\n  'context-labels': {\n    pattern: /\\{[^}]*(?=}?)/,\n    greedy: true,\n    inside: {\n      comment: {\n        pattern: /#.*/,\n      },\n      'label-key': {\n        pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\n        alias: 'attr-name',\n        greedy: true,\n      },\n      'label-value': {\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n        greedy: true,\n        alias: 'attr-value',\n      },\n      punctuation: /[{]/,\n    },\n  },\n  function: new RegExp(`\\\\b(?:${FUNCTIONS.map((f) => f.label).join('|')})(?=\\\\s*\\\\()`, 'i'),\n  'context-range': [\n    {\n      pattern: /\\[[^\\]]*(?=])/, // [1m]\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n    {\n      pattern: /(offset\\s+)\\w+/, // offset 1m\n      lookbehind: true,\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n  ],\n  number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  operator: new RegExp(`/[-+*/=%^~]|&&?|\\\\|?\\\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\\\b(?:${OPERATORS.join('|')})\\\\b`, 'i'),\n  punctuation: /[{};()`,.]/,\n};\n\nexport default tokenizer;\n"],"sourceRoot":""}