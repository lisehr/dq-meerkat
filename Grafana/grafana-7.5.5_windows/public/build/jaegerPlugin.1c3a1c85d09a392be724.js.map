{"version":3,"sources":["webpack:///./public/app/plugins/datasource/jaeger/responseTransform.ts","webpack:///./public/app/plugins/datasource/jaeger/datasource.ts","webpack:///./public/app/plugins/datasource/jaeger/QueryField.tsx","webpack:///./public/app/plugins/datasource/jaeger/module.ts","webpack:///./public/app/plugins/datasource/jaeger/ConfigEditor.tsx","webpack:///./public/app/core/components/TraceToLogsSettings.tsx"],"names":["createTraceFrame","data","spans","map","s","span","processes","spanID","traceID","parentSpanID","references","find","r","refType","operationName","startTime","duration","logs","l","timestamp","tags","warnings","undefined","stackTraces","serviceName","processID","serviceTags","toSpanRow","frame","MutableDataFrame","fields","name","type","FieldType","string","other","number","meta","preferredVisualisationType","add","JaegerDatasource","instanceSettings","timeSrv","getTimeSrv","url","params","this","_request","hideFromInspector","toPromise","res","options","id","targets","query","encodeURIComponent","pipe","response","of","emptyTraceDataFrame","length","status","message","catchError","err","statusText","JSON","stringify","range","timeRange","start","getTime","from","end","to","apiUrl","baseUrl","serializeParams","req","getBackendSrv","datasourceRequest","DataSourceApi","date","roundUp","dateMath","parse","valueOf","trace","values","getLabelFromTrace","rootSpan","JaegerQueryField","props","context","onLoadOptions","selectedOptions","service","value","findOperations","operations","_isMounted","operationOptions","label","sort","operation","isLeaf","setState","state","serviceOptions","serviceOption","children","operationValue","findTraces","traces","traceOptions","operationOption","datasource","metadataRequest","appEvents","emit","AppEvents","alertError","getTimeRange","traceSearch","limit","lookback","maxDuration","minDuration","onSelectTrace","onChange","onRunQuery","getServices","services","cascaderOptions","noTracesFoundOptions","className","loadData","aria-label","selectors","components","QueryField","container","style","width","e","currentTarget","React","PureComponent","plugin","DataSourcePlugin","setConfigEditor","onOptionsChange","defaultUrl","dataSourceConfig","showAccessOptions","TraceToLogsSettings","setExploreQueryField","styles","useStyles","getStyles","infoText","tooltip","pluginId","current","jsonData","tracesToLogs","datasourceUid","noDefault","ds","updateDatasourcePluginJsonDataOption","uid","theme","css","spacing","md","colors","textSemiWeak"],"mappings":"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","file":"jaegerPlugin.1c3a1c85d09a392be724.js","sourcesContent":["import { DataFrame, FieldType, MutableDataFrame, TraceSpanRow } from '@grafana/data';\n\nimport { Span, TraceProcess, TraceResponse } from './types';\n\nexport function createTraceFrame(data: TraceResponse): DataFrame {\n  const spans = data.spans.map((s) => toSpanRow(s, data.processes));\n\n  const frame = new MutableDataFrame({\n    fields: [\n      { name: 'traceID', type: FieldType.string },\n      { name: 'spanID', type: FieldType.string },\n      { name: 'parentSpanID', type: FieldType.string },\n      { name: 'operationName', type: FieldType.string },\n      { name: 'serviceName', type: FieldType.string },\n      { name: 'serviceTags', type: FieldType.other },\n      { name: 'startTime', type: FieldType.number },\n      { name: 'duration', type: FieldType.number },\n      { name: 'logs', type: FieldType.other },\n      { name: 'tags', type: FieldType.other },\n      { name: 'warnings', type: FieldType.other },\n      { name: 'stackTraces', type: FieldType.other },\n    ],\n    meta: {\n      preferredVisualisationType: 'trace',\n    },\n  });\n\n  for (const span of spans) {\n    frame.add(span);\n  }\n\n  return frame;\n}\n\nfunction toSpanRow(span: Span, processes: Record<string, TraceProcess>): TraceSpanRow {\n  return {\n    spanID: span.spanID,\n    traceID: span.traceID,\n    parentSpanID: span.references?.find((r) => r.refType === 'CHILD_OF')?.spanID,\n    operationName: span.operationName,\n    // from micro to millis\n    startTime: span.startTime / 1000,\n    duration: span.duration / 1000,\n    logs: span.logs.map((l) => ({\n      ...l,\n      timestamp: l.timestamp / 1000,\n    })),\n    tags: span.tags,\n    warnings: span.warnings ?? undefined,\n    stackTraces: span.stackTraces,\n    serviceName: processes[span.processID].serviceName,\n    serviceTags: processes[span.processID].tags,\n  };\n}\n","import {\n  DataQuery,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  dateMath,\n  DateTime,\n  FieldType,\n  MutableDataFrame,\n} from '@grafana/data';\nimport { BackendSrvRequest, getBackendSrv } from '@grafana/runtime';\nimport { from, Observable, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\n\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { serializeParams } from 'app/core/utils/fetch';\nimport { createTraceFrame } from './responseTransform';\n\nexport type JaegerQuery = {\n  query: string;\n} & DataQuery;\n\nexport class JaegerDatasource extends DataSourceApi<JaegerQuery> {\n  constructor(private instanceSettings: DataSourceInstanceSettings, private readonly timeSrv: TimeSrv = getTimeSrv()) {\n    super(instanceSettings);\n  }\n\n  async metadataRequest(url: string, params?: Record<string, any>): Promise<any> {\n    const res = await this._request(url, params, { hideFromInspector: true }).toPromise();\n    return res.data.data;\n  }\n\n  query(options: DataQueryRequest<JaegerQuery>): Observable<DataQueryResponse> {\n    // At this moment we expect only one target. In case we somehow change the UI to be able to show multiple\n    // traces at one we need to change this.\n    const id = options.targets[0]?.query;\n    if (!id) {\n      return of({ data: [emptyTraceDataFrame] });\n    }\n\n    // TODO: this api is internal, used in jaeger ui. Officially they have gRPC api that should be used.\n    return this._request(`/api/traces/${encodeURIComponent(id)}`).pipe(\n      map((response) => {\n        return {\n          data: [createTraceFrame(response?.data?.data?.[0] || [])],\n        };\n      })\n    );\n  }\n\n  async testDatasource(): Promise<any> {\n    return this._request('/api/services')\n      .pipe(\n        map((res) => {\n          const values: any[] = res?.data?.data || [];\n          const testResult =\n            values.length > 0\n              ? { status: 'success', message: 'Data source connected and services found.' }\n              : {\n                  status: 'error',\n                  message:\n                    'Data source connected, but no services received. Verify that Jaeger is configured properly.',\n                };\n          return testResult;\n        }),\n        catchError((err: any) => {\n          let message = 'Jaeger: ';\n          if (err.statusText) {\n            message += err.statusText;\n          } else {\n            message += 'Cannot connect to Jaeger';\n          }\n\n          if (err.status) {\n            message += `. ${err.status}`;\n          }\n\n          if (err.data && err.data.message) {\n            message += `. ${err.data.message}`;\n          } else if (err.data) {\n            message += `. ${JSON.stringify(err.data)}`;\n          }\n          return of({ status: 'error', message: message });\n        })\n      )\n      .toPromise();\n  }\n\n  getTimeRange(): { start: number; end: number } {\n    const range = this.timeSrv.timeRange();\n    return {\n      start: getTime(range.from, false),\n      end: getTime(range.to, true),\n    };\n  }\n\n  getQueryDisplayText(query: JaegerQuery) {\n    return query.query;\n  }\n\n  private _request(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<Record<string, any>> {\n    // Hack for proxying metadata requests\n    const baseUrl = `/api/datasources/proxy/${this.instanceSettings.id}`;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return from(getBackendSrv().datasourceRequest(req));\n  }\n}\n\nfunction getTime(date: string | DateTime, roundUp: boolean) {\n  if (typeof date === 'string') {\n    date = dateMath.parse(date, roundUp)!;\n  }\n  return date.valueOf() * 1000;\n}\n\nconst emptyTraceDataFrame = new MutableDataFrame({\n  fields: [\n    {\n      name: 'trace',\n      type: FieldType.trace,\n      values: [],\n    },\n  ],\n  meta: {\n    preferredVisualisationType: 'trace',\n  },\n});\n","import { AppEvents, ExploreQueryFieldProps } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { ButtonCascader, CascaderOption } from '@grafana/ui';\nimport React from 'react';\nimport { appEvents } from '../../../core/core';\nimport { JaegerDatasource, JaegerQuery } from './datasource';\nimport { Span, TraceResponse } from './types';\n\nconst ALL_OPERATIONS_KEY = '__ALL__';\nconst NO_TRACES_KEY = '__NO_TRACES__';\n\ntype Props = ExploreQueryFieldProps<JaegerDatasource, JaegerQuery>;\ninterface State {\n  serviceOptions: CascaderOption[];\n}\n\nfunction findRootSpan(spans: Span[]): Span | undefined {\n  return spans.find((s) => !s.references?.length);\n}\n\nfunction getLabelFromTrace(trace: TraceResponse): string {\n  const rootSpan = findRootSpan(trace.spans);\n  if (rootSpan) {\n    return `${rootSpan.operationName} [${rootSpan.duration / 1000} ms]`;\n  }\n  return trace.traceID;\n}\n\nexport class JaegerQueryField extends React.PureComponent<Props, State> {\n  private _isMounted: boolean;\n\n  constructor(props: Props, context: React.Context<any>) {\n    super(props, context);\n    this.state = {\n      serviceOptions: [],\n    };\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n    // We should probably call this periodically to get new services after mount.\n    this.getServices();\n  }\n\n  componentWillUnmount(): void {\n    this._isMounted = false;\n  }\n\n  async getServices() {\n    const url = '/api/services';\n    const { datasource } = this.props;\n    try {\n      const services: string[] | null = await datasource.metadataRequest(url);\n      if (!this._isMounted) {\n        return;\n      }\n\n      if (services) {\n        const serviceOptions: CascaderOption[] = services.sort().map((service) => ({\n          label: service,\n          value: service,\n          isLeaf: false,\n        }));\n        this.setState({ serviceOptions });\n      }\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load services from Jaeger', error]);\n    }\n  }\n\n  onLoadOptions = async (selectedOptions: CascaderOption[]) => {\n    const service = selectedOptions[0].value;\n    if (selectedOptions.length === 1) {\n      // Load operations\n      const operations: string[] = await this.findOperations(service);\n      if (!this._isMounted) {\n        return;\n      }\n\n      const allOperationsOption: CascaderOption = {\n        label: '[ALL]',\n        value: ALL_OPERATIONS_KEY,\n      };\n      const operationOptions: CascaderOption[] = [\n        allOperationsOption,\n        ...operations.sort().map((operation) => ({\n          label: operation,\n          value: operation,\n          isLeaf: false,\n        })),\n      ];\n      this.setState((state) => {\n        const serviceOptions = state.serviceOptions.map((serviceOption) => {\n          if (serviceOption.value === service) {\n            return {\n              ...serviceOption,\n              children: operationOptions,\n            };\n          }\n          return serviceOption;\n        });\n        return { serviceOptions };\n      });\n    } else if (selectedOptions.length === 2) {\n      // Load traces\n      const operationValue = selectedOptions[1].value;\n      const operation = operationValue === ALL_OPERATIONS_KEY ? '' : operationValue;\n      const traces: any[] = await this.findTraces(service, operation);\n      if (!this._isMounted) {\n        return;\n      }\n\n      let traceOptions: CascaderOption[] = traces.map((trace) => ({\n        label: getLabelFromTrace(trace),\n        value: trace.traceID,\n      }));\n      if (traceOptions.length === 0) {\n        traceOptions = [\n          {\n            label: '[No traces in time range]',\n            value: NO_TRACES_KEY,\n          },\n        ];\n      }\n      this.setState((state) => {\n        // Place new traces into the correct service/operation sub-tree\n        const serviceOptions = state.serviceOptions.map((serviceOption) => {\n          if (serviceOption.value === service && serviceOption.children) {\n            const operationOptions = serviceOption.children.map((operationOption) => {\n              if (operationOption.value === operationValue) {\n                return {\n                  ...operationOption,\n                  children: traceOptions,\n                };\n              }\n              return operationOption;\n            });\n            return {\n              ...serviceOption,\n              children: operationOptions,\n            };\n          }\n          return serviceOption;\n        });\n        return { serviceOptions };\n      });\n    }\n  };\n\n  findOperations = async (service: string) => {\n    const { datasource } = this.props;\n    const url = `/api/services/${encodeURIComponent(service)}/operations`;\n    try {\n      return await datasource.metadataRequest(url);\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load operations from Jaeger', error]);\n    }\n    return [];\n  };\n\n  findTraces = async (service: string, operation?: string) => {\n    const { datasource } = this.props;\n    const { start, end } = datasource.getTimeRange();\n\n    const traceSearch = {\n      start,\n      end,\n      service,\n      operation,\n      limit: 10,\n      lookback: '1h',\n      maxDuration: '',\n      minDuration: '',\n    };\n    const url = '/api/traces';\n    try {\n      return await datasource.metadataRequest(url, traceSearch);\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load traces from Jaeger', error]);\n    }\n    return [];\n  };\n\n  onSelectTrace = (values: string[], selectedOptions: CascaderOption[]) => {\n    const { query, onChange, onRunQuery } = this.props;\n    if (selectedOptions.length === 3) {\n      const traceID = selectedOptions[2].value;\n      onChange({ ...query, query: traceID });\n      onRunQuery();\n    }\n  };\n\n  render() {\n    const { query, onChange } = this.props;\n    const { serviceOptions } = this.state;\n    const cascaderOptions = serviceOptions && serviceOptions.length ? serviceOptions : noTracesFoundOptions;\n\n    return (\n      <>\n        <div className=\"gf-form-inline gf-form-inline--nowrap\">\n          <div className=\"gf-form flex-shrink-0\">\n            <ButtonCascader options={cascaderOptions} onChange={this.onSelectTrace} loadData={this.onLoadOptions}>\n              Traces\n            </ButtonCascader>\n          </div>\n          <div className=\"gf-form gf-form--grow flex-shrink-1\">\n            <div className=\"slate-query-field__wrapper\">\n              <div className=\"slate-query-field\" aria-label={selectors.components.QueryField.container}>\n                <input\n                  style={{ width: '100%' }}\n                  value={query.query || ''}\n                  onChange={(e) =>\n                    onChange({\n                      ...query,\n                      query: e.currentTarget.value,\n                    })\n                  }\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nconst noTracesFoundOptions = [\n  {\n    label: 'No traces found',\n    value: 'no_traces',\n    isLeaf: true,\n\n    // Cannot be disabled because then cascader shows 'loading' for some reason.\n    // disabled: true,\n  },\n];\n\nexport default JaegerQueryField;\n","import { DataSourcePlugin } from '@grafana/data';\nimport { JaegerDatasource } from './datasource';\nimport { JaegerQueryField } from './QueryField';\nimport { ConfigEditor } from './ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(JaegerDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(JaegerQueryField);\n","import { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { TraceToLogsSettings } from 'app/core/components/TraceToLogsSettings';\nimport React from 'react';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor: React.FC<Props> = ({ options, onOptionsChange }) => {\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:16686\"\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <TraceToLogsSettings options={options} onOptionsChange={onOptionsChange} />\n    </>\n  );\n};\n","import {\n  DataSourceJsonData,\n  DataSourcePluginOptionsEditorProps,\n  GrafanaTheme,\n  updateDatasourcePluginJsonDataOption,\n} from '@grafana/data';\nimport { InlineFormLabel, TagsInput, useStyles } from '@grafana/ui';\nimport { css } from 'emotion';\nimport React from 'react';\nimport { DataSourcePicker } from './Select/DataSourcePicker';\n\nexport interface TraceToLogsOptions {\n  datasourceUid?: string;\n  tags?: string[];\n}\n\nexport interface TraceToLogsData extends DataSourceJsonData {\n  tracesToLogs?: TraceToLogsOptions;\n}\n\ninterface Props extends DataSourcePluginOptionsEditorProps<TraceToLogsData> {}\n\nexport function TraceToLogsSettings({ options, onOptionsChange }: Props) {\n  const styles = useStyles(getStyles);\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Trace to logs</h3>\n\n      <div className={styles.infoText}>\n        Trace to logs let&apos;s you navigate from a trace span to the selected data source&apos;s log.\n      </div>\n\n      <div className=\"gf-form\">\n        <InlineFormLabel tooltip=\"The data source the trace is going to navigate to\">Data source</InlineFormLabel>\n        <DataSourcePicker\n          pluginId=\"loki\"\n          current={options.jsonData.tracesToLogs?.datasourceUid}\n          noDefault={true}\n          onChange={(ds) =>\n            updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n              datasourceUid: ds.uid,\n              tags: options.jsonData.tracesToLogs?.tags,\n            })\n          }\n        />\n      </div>\n\n      <div className=\"gf-form\">\n        <InlineFormLabel tooltip=\"Tags that will be used in the Loki query. Default tags: 'cluster', 'hostname', 'namespace', 'pod'\">\n          Tags\n        </InlineFormLabel>\n        <TagsInput\n          tags={options.jsonData.tracesToLogs?.tags}\n          onChange={(tags) =>\n            updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n              datasourceUid: options.jsonData.tracesToLogs?.datasourceUid,\n              tags: tags,\n            })\n          }\n        />\n      </div>\n    </>\n  );\n}\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing.md};\n    color: ${theme.colors.textSemiWeak};\n  `,\n});\n"],"sourceRoot":""}