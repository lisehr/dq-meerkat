{"version":3,"sources":["webpack:///./public/app/features/alerting/components/NotificationSettings.tsx","webpack:///./public/app/features/alerting/components/OptionElement.tsx","webpack:///./public/app/features/alerting/components/NotificationChannelOptions.tsx","webpack:///./public/app/features/alerting/components/BasicSettings.tsx","webpack:///./public/app/features/alerting/components/ChannelSettings.tsx","webpack:///./public/app/features/alerting/components/NotificationChannelForm.tsx","webpack:///./public/app/features/alerting/state/actions.ts","webpack:///./public/app/features/alerting/utils/notificationChannels.ts"],"names":["NotificationSettings","currentFormValues","imageRendererAvailable","register","label","isOpen","name","ref","description","uploadImage","title","sendReminder","width","OptionElement","control","option","invalid","modelValue","secure","propertyName","element","type","inputType","required","validate","v","validationRule","validateOption","placeholder","as","Select","options","selectOptions","console","error","value","RegExp","test","NotificationChannelOptions","errors","selectedChannelOptions","onResetSecureField","secureFields","map","index","key","selectedOptionValue","showWhen","field","is","settings","message","readOnly","suffix","onClick","variant","size","BasicSettings","selectedChannel","channels","resetSecureField","rules","filter","o","ChannelSettings","heading","info","NotificationChannelForm","selectableChannels","watch","getValues","onTestChannel","styles","getStyles","useTheme","fieldsToWatch","Set","useEffect","className","formContainer","formItem","length","formButtons","nest","href","config","appSubUrl","stylesFactory","theme","css","spacing","md","xl","getAlertRulesAsync","dispatch","loadAlertRules","getBackendSrv","get","featureToggles","ngalert","ngAlertDefinitions","setAlertDefinitions","results","loadedAlertRules","togglePauseAlertRule","id","getState","post","stateFilter","location","query","state","toString","createNotificationChannel","data","appEvents","emit","AppEvents","alertSuccess","updateLocation","path","alertError","updateNotificationChannel","put","testNotificationChannel","channel","notificationChannel","loadNotificationTypes","alertNotifiers","notificationTypes","sort","o1","o2","setNotificationChannels","loadNotificationChannel","notificationChannelLoaded","getAlertDefinition","alertDefinition","setAlertDefinition","createAlertDefinition","getStore","buildAlertDefinition","updateAlertDefinition","uid","updatedAlertDefinition","updateAlertDefinitionUiState","uiState","nextState","setUiState","store","setObject","ALERT_DEFINITION_UI_STATE_STORAGE_KEY","updateAlertDefinitionOption","updateAlertDefinitionOptions","queryOptionsChange","queryOptions","setQueryOptions","onRunQueries","queryRunner","timeRange","from","to","getQueryOptions","run","timezone","dateMath","parse","raw","maxDataPoints","minInterval","queries","datasource","dataSource","evaluateAlertDefinition","response","handledResponse","handleBase64Response","instances","setInstanceData","evaluateNotSavedAlertDefinition","getDataSourceSrv","defaultDataSource","condition","buildDataQueryModel","cleanUpDefinitionState","cleanUpState","undefined","currentAlertDefinition","frames","dataFrames","instance","table","base64StringToArrowTable","arrowTableToDataFrame","applyFieldOverrides","fieldConfig","defaults","overrides","replaceVariables","isExpression","ExpressionDatasourceID","dataSourceSetting","getInstanceSettings","model","queryType","datasourceUid","refId","relativeTimeRange","From","To","defaultValues","disableResolveMessage","frequency","rendererAvailable","autoResolve","httpMethod","severity","secureSettings","isDefault","mapChannelsToSelectableValue","memoizeOne","notificationChannels","includeDescription","transformSubmitData","formData","Object","fromEntries","entries","hasOwnProperty","transformTestData","assign"],"mappings":"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","file":"default~EditNotificationChannel~NewNotificationChannel.1c3a1c85d09a392be724.js","sourcesContent":["import React, { FC } from 'react';\nimport { Checkbox, CollapsableSection, Field, InfoBox, Input } from '@grafana/ui';\nimport { NotificationSettingsProps } from './NotificationChannelForm';\n\ninterface Props extends NotificationSettingsProps {\n  imageRendererAvailable: boolean;\n}\n\nexport const NotificationSettings: FC<Props> = ({ currentFormValues, imageRendererAvailable, register }) => {\n  return (\n    <CollapsableSection label=\"Notification settings\" isOpen={false}>\n      <Field>\n        <Checkbox name=\"isDefault\" ref={register} label=\"Default\" description=\"Use this notification for all alerts\" />\n      </Field>\n      <Field>\n        <Checkbox\n          name=\"settings.uploadImage\"\n          ref={register}\n          label=\"Include image\"\n          description=\"Captures an image and include it in the notification\"\n        />\n      </Field>\n      {currentFormValues.uploadImage && !imageRendererAvailable && (\n        <InfoBox title=\"No image renderer available/installed\">\n          Grafana cannot find an image renderer to capture an image for the notification. Please make sure the Grafana\n          Image Renderer plugin is installed. Please contact your Grafana administrator to install the plugin.\n        </InfoBox>\n      )}\n      <Field>\n        <Checkbox\n          name=\"disableResolveMessage\"\n          ref={register}\n          label=\"Disable Resolve Message\"\n          description=\"Disable the resolve message [OK] that is sent when alerting state returns to false\"\n        />\n      </Field>\n      <Field>\n        <Checkbox\n          name=\"sendReminder\"\n          ref={register}\n          label=\"Send reminders\"\n          description=\"Send additional notifications for triggered alerts\"\n        />\n      </Field>\n      {currentFormValues.sendReminder && (\n        <>\n          <Field\n            label=\"Send reminder every\"\n            description=\"Specify how often reminders should be sent, e.g. every 30s, 1m, 10m, 30m or 1h etc.\n            Alert reminders are sent after rules are evaluated. Therefore a reminder can never be sent more frequently\n            than a configured alert rule evaluation interval.\"\n          >\n            <Input name=\"frequency\" ref={register} width={8} />\n          </Field>\n        </>\n      )}\n    </CollapsableSection>\n  );\n};\n","import React, { FC } from 'react';\nimport { FormAPI, Input, InputControl, Select, TextArea } from '@grafana/ui';\nimport { NotificationChannelOption } from '../../../types';\n\ninterface Props extends Pick<FormAPI<any>, 'register' | 'control'> {\n  option: NotificationChannelOption;\n  invalid?: boolean;\n}\n\nexport const OptionElement: FC<Props> = ({ control, option, register, invalid }) => {\n  const modelValue = option.secure ? `secureSettings.${option.propertyName}` : `settings.${option.propertyName}`;\n  switch (option.element) {\n    case 'input':\n      return (\n        <Input\n          invalid={invalid}\n          type={option.inputType}\n          name={`${modelValue}`}\n          ref={register({\n            required: option.required ? 'Required' : false,\n            validate: (v) => (option.validationRule !== '' ? validateOption(v, option.validationRule) : true),\n          })}\n          placeholder={option.placeholder}\n        />\n      );\n\n    case 'select':\n      return (\n        <InputControl\n          as={Select}\n          options={option.selectOptions}\n          control={control}\n          name={`${modelValue}`}\n          invalid={invalid}\n        />\n      );\n\n    case 'textarea':\n      return (\n        <TextArea\n          invalid={invalid}\n          name={`${modelValue}`}\n          ref={register({\n            required: option.required ? 'Required' : false,\n            validate: (v) => (option.validationRule !== '' ? validateOption(v, option.validationRule) : true),\n          })}\n        />\n      );\n\n    default:\n      console.error('Element not supported', option.element);\n      return null;\n  }\n};\n\nconst validateOption = (value: string, validationRule: string) => {\n  return RegExp(validationRule).test(value) ? true : 'Invalid format';\n};\n","import React, { FC } from 'react';\nimport { SelectableValue } from '@grafana/data';\nimport { Button, Checkbox, Field, FormAPI, Input } from '@grafana/ui';\nimport { OptionElement } from './OptionElement';\nimport { NotificationChannelDTO, NotificationChannelOption, NotificationChannelSecureFields } from '../../../types';\n\ninterface Props extends Omit<FormAPI<NotificationChannelDTO>, 'formState' | 'getValues' | 'watch'> {\n  selectedChannelOptions: NotificationChannelOption[];\n  currentFormValues: NotificationChannelDTO;\n  secureFields: NotificationChannelSecureFields;\n\n  onResetSecureField: (key: string) => void;\n}\n\nexport const NotificationChannelOptions: FC<Props> = ({\n  control,\n  currentFormValues,\n  errors,\n  selectedChannelOptions,\n  register,\n  onResetSecureField,\n  secureFields,\n}) => {\n  return (\n    <>\n      {selectedChannelOptions.map((option: NotificationChannelOption, index: number) => {\n        const key = `${option.label}-${index}`;\n        // Some options can be dependent on other options, this determines what is selected in the dependency options\n        // I think this needs more thought.\n        const selectedOptionValue =\n          currentFormValues[`settings.${option.showWhen.field}`] &&\n          (currentFormValues[`settings.${option.showWhen.field}`] as SelectableValue<string>).value;\n\n        if (option.showWhen.field && selectedOptionValue !== option.showWhen.is) {\n          return null;\n        }\n\n        if (option.element === 'checkbox') {\n          return (\n            <Field key={key}>\n              <Checkbox\n                name={option.secure ? `secureSettings.${option.propertyName}` : `settings.${option.propertyName}`}\n                ref={register}\n                label={option.label}\n                description={option.description}\n              />\n            </Field>\n          );\n        }\n        return (\n          <Field\n            key={key}\n            label={option.label}\n            description={option.description}\n            invalid={errors.settings && !!errors.settings[option.propertyName]}\n            error={errors.settings && errors.settings[option.propertyName]?.message}\n          >\n            {secureFields && secureFields[option.propertyName] ? (\n              <Input\n                readOnly={true}\n                value=\"Configured\"\n                suffix={\n                  <Button\n                    onClick={() => onResetSecureField(option.propertyName)}\n                    variant=\"link\"\n                    type=\"button\"\n                    size=\"sm\"\n                  >\n                    Clear\n                  </Button>\n                }\n              />\n            ) : (\n              <OptionElement option={option} register={register} control={control} />\n            )}\n          </Field>\n        );\n      })}\n    </>\n  );\n};\n","import React, { FC } from 'react';\nimport { SelectableValue } from '@grafana/data';\nimport { Field, Input, InputControl, Select } from '@grafana/ui';\nimport { NotificationChannelOptions } from './NotificationChannelOptions';\nimport { NotificationSettingsProps } from './NotificationChannelForm';\nimport { NotificationChannelSecureFields, NotificationChannelType } from '../../../types';\n\ninterface Props extends NotificationSettingsProps {\n  selectedChannel: NotificationChannelType;\n  channels: Array<SelectableValue<string>>;\n  secureFields: NotificationChannelSecureFields;\n  resetSecureField: (key: string) => void;\n}\n\nexport const BasicSettings: FC<Props> = ({\n  control,\n  currentFormValues,\n  errors,\n  secureFields,\n  selectedChannel,\n  channels,\n  register,\n  resetSecureField,\n}) => {\n  return (\n    <>\n      <Field label=\"Name\" invalid={!!errors.name} error={errors.name && errors.name.message}>\n        <Input name=\"name\" ref={register({ required: 'Name is required' })} />\n      </Field>\n      <Field label=\"Type\">\n        <InputControl name=\"type\" as={Select} options={channels} control={control} rules={{ required: true }} />\n      </Field>\n      <NotificationChannelOptions\n        selectedChannelOptions={selectedChannel.options.filter((o) => o.required)}\n        currentFormValues={currentFormValues}\n        secureFields={secureFields}\n        onResetSecureField={resetSecureField}\n        register={register}\n        errors={errors}\n        control={control}\n      />\n    </>\n  );\n};\n","import React, { FC } from 'react';\nimport { CollapsableSection, InfoBox } from '@grafana/ui';\nimport { NotificationChannelOptions } from './NotificationChannelOptions';\nimport { NotificationSettingsProps } from './NotificationChannelForm';\nimport { NotificationChannelSecureFields, NotificationChannelType } from '../../../types';\n\ninterface Props extends NotificationSettingsProps {\n  selectedChannel: NotificationChannelType;\n  secureFields: NotificationChannelSecureFields;\n  resetSecureField: (key: string) => void;\n}\n\nexport const ChannelSettings: FC<Props> = ({\n  control,\n  currentFormValues,\n  errors,\n  selectedChannel,\n  secureFields,\n  register,\n  resetSecureField,\n}) => {\n  return (\n    <CollapsableSection label={`Optional ${selectedChannel.heading}`} isOpen={false}>\n      {selectedChannel.info !== '' && <InfoBox>{selectedChannel.info}</InfoBox>}\n      <NotificationChannelOptions\n        selectedChannelOptions={selectedChannel.options.filter((o) => !o.required)}\n        currentFormValues={currentFormValues}\n        register={register}\n        errors={errors}\n        control={control}\n        onResetSecureField={resetSecureField}\n        secureFields={secureFields}\n      />\n    </CollapsableSection>\n  );\n};\n","import React, { FC, useEffect } from 'react';\nimport { css } from 'emotion';\nimport { GrafanaTheme, SelectableValue } from '@grafana/data';\nimport { Button, FormAPI, HorizontalGroup, stylesFactory, useTheme, Spinner } from '@grafana/ui';\nimport { NotificationChannelType, NotificationChannelDTO, NotificationChannelSecureFields } from '../../../types';\nimport { NotificationSettings } from './NotificationSettings';\nimport { BasicSettings } from './BasicSettings';\nimport { ChannelSettings } from './ChannelSettings';\n\nimport config from 'app/core/config';\n\ninterface Props extends Omit<FormAPI<NotificationChannelDTO>, 'formState'> {\n  selectableChannels: Array<SelectableValue<string>>;\n  selectedChannel?: NotificationChannelType;\n  imageRendererAvailable: boolean;\n  secureFields: NotificationChannelSecureFields;\n  resetSecureField: (key: string) => void;\n  onTestChannel: (data: NotificationChannelDTO) => void;\n}\n\nexport interface NotificationSettingsProps\n  extends Omit<FormAPI<NotificationChannelDTO>, 'formState' | 'watch' | 'getValues'> {\n  currentFormValues: NotificationChannelDTO;\n}\n\nexport const NotificationChannelForm: FC<Props> = ({\n  control,\n  errors,\n  selectedChannel,\n  selectableChannels,\n  register,\n  watch,\n  getValues,\n  imageRendererAvailable,\n  onTestChannel,\n  resetSecureField,\n  secureFields,\n}) => {\n  const styles = getStyles(useTheme());\n\n  /*\n   Finds fields that have dependencies on other fields and removes duplicates.\n   Needs to be prefixed with settings.\n  */\n  const fieldsToWatch =\n    new Set(\n      selectedChannel?.options\n        .filter((o) => o.showWhen.field)\n        .map((option) => {\n          return `settings.${option.showWhen.field}`;\n        })\n    ) || [];\n\n  useEffect(() => {\n    watch(['type', 'sendReminder', 'uploadImage', ...fieldsToWatch]);\n  }, [fieldsToWatch]);\n\n  const currentFormValues = getValues();\n\n  if (!selectedChannel) {\n    return <Spinner />;\n  }\n\n  return (\n    <div className={styles.formContainer}>\n      <div className={styles.formItem}>\n        <BasicSettings\n          selectedChannel={selectedChannel}\n          channels={selectableChannels}\n          secureFields={secureFields}\n          resetSecureField={resetSecureField}\n          currentFormValues={currentFormValues}\n          register={register}\n          errors={errors}\n          control={control}\n        />\n      </div>\n      {/* If there are no non-required fields, don't render this section*/}\n      {selectedChannel.options.filter((o) => !o.required).length > 0 && (\n        <div className={styles.formItem}>\n          <ChannelSettings\n            selectedChannel={selectedChannel}\n            secureFields={secureFields}\n            resetSecureField={resetSecureField}\n            currentFormValues={currentFormValues}\n            register={register}\n            errors={errors}\n            control={control}\n          />\n        </div>\n      )}\n      <div className={styles.formItem}>\n        <NotificationSettings\n          imageRendererAvailable={imageRendererAvailable}\n          currentFormValues={currentFormValues}\n          register={register}\n          errors={errors}\n          control={control}\n        />\n      </div>\n      <div className={styles.formButtons}>\n        <HorizontalGroup>\n          <Button type=\"submit\">Save</Button>\n          <Button type=\"button\" variant=\"secondary\" onClick={() => onTestChannel(getValues({ nest: true }))}>\n            Test\n          </Button>\n          <a href={`${config.appSubUrl}/alerting/notifications`}>\n            <Button type=\"button\" variant=\"secondary\">\n              Back\n            </Button>\n          </a>\n        </HorizontalGroup>\n      </div>\n    </div>\n  );\n};\n\nconst getStyles = stylesFactory((theme: GrafanaTheme) => {\n  return {\n    formContainer: css``,\n    formItem: css`\n      flex-grow: 1;\n      padding-top: ${theme.spacing.md};\n    `,\n    formButtons: css`\n      padding-top: ${theme.spacing.xl};\n    `,\n  };\n});\n","import {\n  AppEvents,\n  applyFieldOverrides,\n  arrowTableToDataFrame,\n  base64StringToArrowTable,\n  DataSourceApi,\n  dateMath,\n} from '@grafana/data';\nimport { config, getBackendSrv, getDataSourceSrv } from '@grafana/runtime';\nimport { appEvents } from 'app/core/core';\nimport { updateLocation } from 'app/core/actions';\nimport store from 'app/core/store';\nimport {\n  ALERT_DEFINITION_UI_STATE_STORAGE_KEY,\n  cleanUpState,\n  loadAlertRules,\n  loadedAlertRules,\n  notificationChannelLoaded,\n  setAlertDefinition,\n  setAlertDefinitions,\n  setInstanceData,\n  setNotificationChannels,\n  setQueryOptions,\n  setUiState,\n  updateAlertDefinitionOptions,\n} from './reducers';\nimport {\n  AlertDefinition,\n  AlertDefinitionState,\n  AlertDefinitionUiState,\n  AlertRuleDTO,\n  NotifierDTO,\n  QueryGroupDataSource,\n  QueryGroupOptions,\n  ThunkResult,\n} from 'app/types';\nimport { ExpressionDatasourceID } from '../../expressions/ExpressionDatasource';\nimport { ExpressionQuery } from '../../expressions/types';\n\nexport function getAlertRulesAsync(options: { state: string }): ThunkResult<void> {\n  return async (dispatch) => {\n    dispatch(loadAlertRules());\n    const rules: AlertRuleDTO[] = await getBackendSrv().get('/api/alerts', options);\n\n    if (config.featureToggles.ngalert) {\n      const ngAlertDefinitions = await getBackendSrv().get('/api/alert-definitions');\n      dispatch(setAlertDefinitions(ngAlertDefinitions.results));\n    }\n\n    dispatch(loadedAlertRules(rules));\n  };\n}\n\nexport function togglePauseAlertRule(id: number, options: { paused: boolean }): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    await getBackendSrv().post(`/api/alerts/${id}/pause`, options);\n    const stateFilter = getState().location.query.state || 'all';\n    dispatch(getAlertRulesAsync({ state: stateFilter.toString() }));\n  };\n}\n\nexport function createNotificationChannel(data: any): ThunkResult<void> {\n  return async (dispatch) => {\n    try {\n      await getBackendSrv().post(`/api/alert-notifications`, data);\n      appEvents.emit(AppEvents.alertSuccess, ['Notification created']);\n      dispatch(updateLocation({ path: 'alerting/notifications' }));\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, [error.data.error]);\n    }\n  };\n}\n\nexport function updateNotificationChannel(data: any): ThunkResult<void> {\n  return async (dispatch) => {\n    try {\n      await getBackendSrv().put(`/api/alert-notifications/${data.id}`, data);\n      appEvents.emit(AppEvents.alertSuccess, ['Notification updated']);\n      dispatch(updateLocation({ path: 'alerting/notifications' }));\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, [error.data.error]);\n    }\n  };\n}\n\nexport function testNotificationChannel(data: any): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    const channel = getState().notificationChannel.notificationChannel;\n    await getBackendSrv().post('/api/alert-notifications/test', { id: channel.id, ...data });\n  };\n}\n\nexport function loadNotificationTypes(): ThunkResult<void> {\n  return async (dispatch) => {\n    const alertNotifiers: NotifierDTO[] = await getBackendSrv().get(`/api/alert-notifiers`);\n\n    const notificationTypes = alertNotifiers.sort((o1, o2) => {\n      if (o1.name > o2.name) {\n        return 1;\n      }\n      return -1;\n    });\n\n    dispatch(setNotificationChannels(notificationTypes));\n  };\n}\n\nexport function loadNotificationChannel(id: number): ThunkResult<void> {\n  return async (dispatch) => {\n    await dispatch(loadNotificationTypes());\n    const notificationChannel = await getBackendSrv().get(`/api/alert-notifications/${id}`);\n    dispatch(notificationChannelLoaded(notificationChannel));\n  };\n}\n\nexport function getAlertDefinition(id: string): ThunkResult<void> {\n  return async (dispatch) => {\n    const alertDefinition = await getBackendSrv().get(`/api/alert-definitions/${id}`);\n    dispatch(setAlertDefinition(alertDefinition));\n  };\n}\n\nexport function createAlertDefinition(): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    const alertDefinition = await buildAlertDefinition(getStore().alertDefinition);\n\n    await getBackendSrv().post(`/api/alert-definitions`, alertDefinition);\n    appEvents.emit(AppEvents.alertSuccess, ['Alert definition created']);\n    dispatch(updateLocation({ path: 'alerting/list' }));\n  };\n}\n\nexport function updateAlertDefinition(): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    const alertDefinition = await buildAlertDefinition(getStore().alertDefinition);\n\n    const updatedAlertDefinition = await getBackendSrv().put(\n      `/api/alert-definitions/${alertDefinition.uid}`,\n      alertDefinition\n    );\n    appEvents.emit(AppEvents.alertSuccess, ['Alert definition updated']);\n    dispatch(setAlertDefinition(updatedAlertDefinition));\n  };\n}\n\nexport function updateAlertDefinitionUiState(uiState: Partial<AlertDefinitionUiState>): ThunkResult<void> {\n  return (dispatch, getStore) => {\n    const nextState = { ...getStore().alertDefinition.uiState, ...uiState };\n    dispatch(setUiState(nextState));\n\n    try {\n      store.setObject(ALERT_DEFINITION_UI_STATE_STORAGE_KEY, nextState);\n    } catch (error) {\n      console.error(error);\n    }\n  };\n}\n\nexport function updateAlertDefinitionOption(alertDefinition: Partial<AlertDefinition>): ThunkResult<void> {\n  return (dispatch) => {\n    dispatch(updateAlertDefinitionOptions(alertDefinition));\n  };\n}\n\nexport function queryOptionsChange(queryOptions: QueryGroupOptions): ThunkResult<void> {\n  return (dispatch) => {\n    dispatch(setQueryOptions(queryOptions));\n  };\n}\n\nexport function onRunQueries(): ThunkResult<void> {\n  return (dispatch, getStore) => {\n    const { queryRunner, getQueryOptions } = getStore().alertDefinition;\n    const timeRange = { from: 'now-1h', to: 'now' };\n    const queryOptions = getQueryOptions();\n\n    queryRunner!.run({\n      // if the queryRunner is undefined here somethings very wrong so it's ok to throw an unhandled error\n      timezone: 'browser',\n      timeRange: { from: dateMath.parse(timeRange.from)!, to: dateMath.parse(timeRange.to)!, raw: timeRange },\n      maxDataPoints: queryOptions.maxDataPoints ?? 100,\n      minInterval: queryOptions.minInterval,\n      queries: queryOptions.queries,\n      datasource: queryOptions.dataSource.name!,\n    });\n  };\n}\n\nexport function evaluateAlertDefinition(): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    const { alertDefinition } = getStore().alertDefinition;\n\n    const response: { instances: string[] } = await getBackendSrv().get(\n      `/api/alert-definitions/eval/${alertDefinition.uid}`\n    );\n\n    const handledResponse = handleBase64Response(response.instances);\n\n    dispatch(setInstanceData(handledResponse));\n    appEvents.emit(AppEvents.alertSuccess, ['Alert definition tested successfully']);\n  };\n}\n\nexport function evaluateNotSavedAlertDefinition(): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    const { alertDefinition, getQueryOptions } = getStore().alertDefinition;\n    const defaultDataSource = await getDataSourceSrv().get(null);\n\n    const response: { instances: string[] } = await getBackendSrv().post('/api/alert-definitions/eval', {\n      condition: alertDefinition.condition,\n      data: buildDataQueryModel(getQueryOptions(), defaultDataSource),\n    });\n\n    const handledResponse = handleBase64Response(response.instances);\n    dispatch(setInstanceData(handledResponse));\n    appEvents.emit(AppEvents.alertSuccess, ['Alert definition tested successfully']);\n  };\n}\n\nexport function cleanUpDefinitionState(): ThunkResult<void> {\n  return (dispatch) => {\n    dispatch(cleanUpState(undefined));\n  };\n}\n\nasync function buildAlertDefinition(state: AlertDefinitionState) {\n  const queryOptions = state.getQueryOptions();\n  const currentAlertDefinition = state.alertDefinition;\n  const defaultDataSource = await getDataSourceSrv().get(null);\n\n  return {\n    ...currentAlertDefinition,\n    data: buildDataQueryModel(queryOptions, defaultDataSource),\n  };\n}\n\nfunction handleBase64Response(frames: string[]) {\n  const dataFrames = frames.map((instance) => {\n    const table = base64StringToArrowTable(instance);\n    return arrowTableToDataFrame(table);\n  });\n\n  return applyFieldOverrides({\n    data: dataFrames,\n    fieldConfig: {\n      defaults: {},\n      overrides: [],\n    },\n    replaceVariables: (value: any) => value,\n    theme: config.theme,\n  });\n}\n\nfunction buildDataQueryModel(queryOptions: QueryGroupOptions, defaultDataSource: DataSourceApi) {\n  return queryOptions.queries.map((query) => {\n    let dataSource: QueryGroupDataSource;\n    const isExpression = query.datasource === ExpressionDatasourceID;\n\n    if (isExpression) {\n      dataSource = { name: ExpressionDatasourceID, uid: ExpressionDatasourceID };\n    } else {\n      const dataSourceSetting = getDataSourceSrv().getInstanceSettings(query.datasource);\n\n      dataSource = {\n        name: dataSourceSetting?.name ?? defaultDataSource.name,\n        uid: dataSourceSetting?.uid ?? defaultDataSource.uid,\n      };\n    }\n\n    return {\n      model: {\n        ...query,\n        type: isExpression ? (query as ExpressionQuery).type : query.queryType,\n        datasource: dataSource.name,\n        datasourceUid: dataSource.uid,\n      },\n      refId: query.refId,\n      relativeTimeRange: {\n        From: 500,\n        To: 0,\n      },\n    };\n  });\n}\n","import memoizeOne from 'memoize-one';\nimport { SelectableValue } from '@grafana/data';\nimport { config } from '@grafana/runtime';\nimport { NotificationChannelDTO, NotificationChannelType } from 'app/types';\n\nexport const defaultValues: NotificationChannelDTO = {\n  id: -1,\n  name: '',\n  type: { value: 'email', label: 'Email' },\n  sendReminder: false,\n  disableResolveMessage: false,\n  frequency: '15m',\n  settings: {\n    uploadImage: config.rendererAvailable,\n    autoResolve: true,\n    httpMethod: 'POST',\n    severity: 'critical',\n  },\n  secureSettings: {},\n  secureFields: {},\n  isDefault: false,\n};\n\nexport const mapChannelsToSelectableValue = memoizeOne(\n  (notificationChannels: NotificationChannelType[], includeDescription: boolean): Array<SelectableValue<string>> => {\n    return notificationChannels.map((channel) => {\n      if (includeDescription) {\n        return {\n          value: channel.value,\n          label: channel.label,\n          description: channel.description,\n        };\n      }\n      return {\n        value: channel.value,\n        label: channel.label,\n      };\n    });\n  }\n);\n\nexport const transformSubmitData = (formData: NotificationChannelDTO) => {\n  /*\n    Some settings can be options in a select, in order to not save a SelectableValue<T>\n    we need to use check if it is a SelectableValue and use its value.\n  */\n  const settings = Object.fromEntries(\n    Object.entries(formData.settings).map(([key, value]) => {\n      return [key, value && value.hasOwnProperty('value') ? value.value : value];\n    })\n  );\n\n  return {\n    ...defaultValues,\n    ...formData,\n    frequency: formData.frequency === '' ? defaultValues.frequency : formData.frequency,\n    type: formData.type.value,\n    settings: { ...defaultValues.settings, ...settings },\n    secureSettings: { ...formData.secureSettings },\n  };\n};\n\nexport const transformTestData = (formData: NotificationChannelDTO) => {\n  return {\n    name: formData.name,\n    type: formData.type.value,\n    frequency: formData.frequency ?? defaultValues.frequency,\n    settings: { ...Object.assign(defaultValues.settings, formData.settings) },\n    secureSettings: { ...formData.secureSettings },\n  };\n};\n"],"sourceRoot":""}